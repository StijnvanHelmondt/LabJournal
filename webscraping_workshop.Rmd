---
title: "Workshop webscraping"
output:
  html_document:
    toc: true
    number_sections: true
author: "by: Stijn van Helmondt"
bibliography: references.bib


---

# 11.6.1 - Setting up the script

```{r}
######################################### Title: Webscraping in R
######################################### 20-09-2023

# start with clean workspace
# rm(list = ls())

# install.packages("data.table")
library(data.table)  # Package for faster data handling
library(tidyverse)  
# install.packages('httr')
library(httr) # we don't need this for now require(httr)
# install.packages("xml2")
require(xml2)
# install.packages("rvest")
require(rvest)
# install.packages("devtools")
require(devtools)



# devtools::install_github("jkeirstead/scholar")

require(scholar)

# setwd(dirname(rstudioapi::getSourceEditorContext()$path))

```

# 11.6.2 - Acquiring anchor data

```{r}

# Let's first get the staff page read_html is a function that simply extracts html webpages and puts them in xml format
soc_staff <- read_html("https://www.ru.nl/sociology/research/staff/")
head(soc_staff)

class(soc_staff)

# so we need to find WHERE the table is located in the html 'inspect element' in mozilla firefox or 'view page source' and you see that everything AFTER /td in the 'body' of the page seems to be the table we do need
soc_staff <- soc_staff %>%
    rvest::html_nodes("body") %>%
    xml2::xml_find_all("//td") %>%
    rvest::html_text()

soc_staff

fodd <- function(x) x%%2 != 0
feven <- function(x) x%%2 == 0

nstaf <- length(soc_staff)
nstaf

# Do you understand why we need the nstaf? What it does? --> nstaf gives the number of staff in the department of Sociology
soc_names <- soc_staff[fodd(1:nstaf)]  
head(soc_names)

soc_experts <- soc_staff[feven(1:nstaf)]
head(soc_experts)

soc_df <- data.frame(cbind(soc_names, soc_experts))  # columnbind those and we have a DF for soc staff!
soc_df

# inspect again, and remove the rows we don't need (check for yourself to be certain!)

delrows <- which(soc_df$soc_names == "Staff:" | soc_df$soc_names == "PhD:" | soc_df$soc_names == "External PhD:" |
    soc_df$soc_names == "Guest researchers:" | soc_df$soc_names == "Other researchers:")

soc_df <- soc_df[-delrows, ]
soc_df

# Last name seems to be everything before the comma
soc_df$last_name <- gsub(",.*$", "", soc_df$soc_names)

# first name is everything between brackets
soc_df$first_name <- str_extract_all(soc_df$soc_names, "(?<=\\().+?(?=\\))", simplify = TRUE)

soc_df$last_name <- gsub(" J. \\(Jansje\\) van MSc", "", soc_df$last_name)
soc_df$first_name <- tolower(soc_df$first_name)  # everything to lower!
soc_df$last_name <- tolower(soc_df$last_name)

# trimws looses all spacing before and after (if you specify 'both') a character string
soc_df$last_name <- trimws(soc_df$last_name, which = c("both"), whitespace = "[ \t\r\n]")
soc_df$first_name <- trimws(soc_df$first_name, which = c("both"), whitespace = "[ \t\r\n]")
soc_df$soc_experts <- trimws(soc_df$soc_experts, which = c("both"), whitespace = "[ \t\r\n]")
soc_df$soc_names <- trimws(soc_df$soc_names, which = c("both"), whitespace = "[ \t\r\n]")

# set affiliation to radboud, comes in handy for querying google scholar
soc_df$affiliation <- "radboud university"

soc_df
```
# 11.6.3 - Google Scholar Profiles & Publications 

```{r}
# The 'for loop': for every i in a vector (can be numbers, strings, etc.), say 1 to 10, you can do
# 'something'
for (i in 1:10) {
    print(i)  # So for every i from 1 to 10, we print i, see what happens!
}

# # or do something more complicated 
p <- rnorm(10, 0, 1) 
p
# draw 10 normally distributed numbers with mean 0 and SD 1 (so z-scores, essentially) 
plot(density(p)) 
# relatively, normal, right?  
u <- 0 # make an element we can fill up in the loop below for (i in 1:10) 
{ u[i] <- p[i]*p[i] } # get p-squared for every i-th element in vector p 
print(u[i]) # and print that squared element

soc_df$gs_id <- ""  # we set an empty identifier

source("function_fix.R")  # Put the function_fix.R in your working directory, we need this first line.

get_scholar_id_fix(last_name = "tolsma", first_name = "jochem", affiliation = "radboud university")
get_profile("Iu23-90AAAAJ")  # Jochem's profile
get_publications("Iu23-90AAAAJ")  # Jochem's publications

get_citation_history("Iu23-90AAAAJ")  # Jochem's citation history

jochem_coauthors <- get_coauthors("Iu23-90AAAAJ", n_coauthors = 50, n_deep = 1)  # Jochem's collaborators and their co-authors! n_deep = 1 means that the co-authors of Jochems network are one layer further than Jochem himself
jochem_coauthors

plot_coauthors(get_coauthors("Iu23-90AAAAJ", n_coauthors = 20, n_deep = 1), size_labels = 2)  # Visualisation of Jochems network. Doesn't look like much yet, but we'll make it prettier later.

# Now for all staff members of the sociology department. Because we don't wanna 'Rate limit' google scholar, they throw you out if you make to many requests, we randomize request time do you understand the code below?
for (i in 1:10) {
    time <- runif(1, 0, 5)
    Sys.sleep(time)
    print(paste(i, ": R slept for", round(time, 1), "seconds"))
}
# for every number from 1 to 10 we draw one number from 0 to 5 from a uniform distribution we put the wrapper sys.sleep around it that we put R to sleep for the drawn number
```


```{r, eval=FALSE}
# Look through get_scholar_id_fix(last_name, first_name, affiliation) if we can find google scholar profiles of sociology staff!
for (i in 1:nrow(soc_df)) {
  
  time <- runif(1, 0, 5)
  Sys.sleep(time)
  
  tryCatch({
     soc_df[i,c("gs_id")] <- get_scholar_id_fix(last_name = soc_df[i, c("last_name")], # so search on last_name of staff (third column)
                                             first_name = soc_df[i, c("first_name")],  # search on first_name of staff (fourth column)
                                             affiliation = soc_df[i,c("affiliation")]) # search on affiliation of each staff (fifth column)

    }, error=function(e){cat("ERROR :", conditionMessage(e), "\n")}) # continue on error, but print the error
  }

# remove those without pubs from the df
# seems we're left with about 34 sociology staff members!
soc_df <- soc_df[!soc_df$gs_id == "", ]
soc_df

nrow(soc_df)

# save(soc_df, file = "addfiles/soc_df_trouble.RData")
```


```{r, eval=FALSE}
soc_list_profiles <- list()  # firstcreate an empty list that I then fill up with the for loop
soc_list_publications <- list()


for (i in 1:nrow(soc_df)) {

    time <- runif(1, 0, 5)
    Sys.sleep(time)

    # note how you call different elements in a list '[[]]', fill in the i-th element
soc_list_profiles[[i]] <- get_profile(soc_df[i, c("gs_id")])  # Note how we call row i (remember how to call rows in a DF/Matrix) and then the associated scholar id
    soc_list_publications[[i]] <- get_publications(soc_df[i, c("gs_id")])
    soc_list_publications[[i]][, c("gs_id")] <- soc_df[i, c("gs_id")]  # note that we again attach an id, so both functions here call the entire profile and pubs for an author, based on google scholar ids

}
# Notice how fast the data blow up! The 34 RU sociology scholars publish ~3000 papers
soc_df_publications <- bind_rows(soc_list_publications)


soc_profiles_df <- list()
for (i in 1:length(soc_list_profiles)) {
    # soc_profiles_df[[i]] <- data.frame(t(unlist(soc_list_profiles[[i]][1:8]))) #some annyoing data handling
    soc_profiles_df[[i]] <- unlist(soc_list_profiles[[i]][1:8])
    soc_profiles_df[[i]] <- data.frame(soc_profiles_df[[i]])
    soc_profiles_df[[i]] <- t(soc_profiles_df[[i]])

}
soc_profiles_df <- bind_rows(soc_profiles_df)
soc_df <- left_join(soc_df, soc_profiles_df, by = c(gs_id = "id"))  # merge data with soc_df
soc_df  # notice all the new information we were able to get from the scholar profiles!

# get citation history of a scholar
soc_staff_cit <- list()
for (i in 1:nrow(soc_df)) {

    soc_staff_cit[[i]] <- get_citation_history(soc_df[i, c("gs_id")])

    if (nrow(soc_staff_cit[[i]]) > 0) {
        soc_staff_cit[[i]][, c("gs_id")] <- soc_df[i, c("gs_id")]  # again attach the gs_id as third column
    }
}
soc_staff_cit <- bind_rows(soc_staff_cit)
colnames(soc_staff_cit)[3] <- "gs_id"
```

# 11.6.4 - Getting collaborators

```{r, eval=FALSE}
source("fcollabs.R")  

# first the soc collaborators note how we already build a function (fcollabs()) for you you need to input a google scholar id and a 1 (if you want to find collabs) or 0 (only extracting names)
# fcollabs --> you can check it out if you're interested
soc_collabs <- list(1)
for (i in 1:nrow(soc_df)) {

    time <- runif(1, 0, 5)
    Sys.sleep(time)

    soc_collabs[[i]] <- fcollabs(soc_df[i, c("gs_id")], 1)

}
soc_collabs <- bind_rows(soc_collabs)  # bind rows, get the unique ones!
soc_collabs_unique <- unique(soc_collabs[, 3])  # so 229 unique collaborators for RU staff?
soc_collabs_unique <- soc_collabs_unique[!is.na(soc_collabs_unique)]
save(soc_collabs, file = "soc_df_collabs1.RData")  # you notice this takes a while, so we save the data here.




```

```{r, eval=FALSE}
# Continuation collaborators
# then the names of those collaborators plus THEIR collaborators understand that we don't have names of them yet from the code above?
collabs_1deep <- list()
for (i in 1:length(soc_collabs_unique)) {

    time <- runif(1, 0, 3)
    Sys.sleep(time)

    if (!soc_collabs_unique[i] %in% soc_df$gs_id) {
        collabs_1deep[[i]] <- fcollabs(soc_collabs_unique[i], 1)

    }
}
collabs_1deep <- bind_rows(collabs_1deep)
collabs_1deep_unique <- unique(collabs_1deep[, 2])
collabs_1deep_unique <- collabs_1deep_unique[!is.na(collabs_1deep_unique)]
save(collabs_1deep, file = "addfiles/soc_collabs2.RData")  # you notice this takes a while, so we save the data here.

for (i in c("_ukytQYAAAAJ", "lkVq32sAAAAJ", "p3IwtT4AAAAJ")) {
    soc_df <- soc_df[!soc_df$gs_id == i, ]
    soc_df_publications <- soc_df_publications[!(soc_df_publications$gs_id == i), ]
    soc_staff_cit <- soc_staff_cit[!(soc_staff_cit$gs_id == i), ]
    soc_collabs <- soc_collabs[!(soc_collabs$gs_id == i), ]
}

```

