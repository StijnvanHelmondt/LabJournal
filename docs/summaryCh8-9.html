<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="by: Stijn van Helmondt" />


<title>Summary Chapter 8 and 9</title>

<script src="site_libs/header-attrs-2.24/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    My journal
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 1</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="test.html">test1</a>
        </li>
        <li>
          <a href="test.html">test2</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 2</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="pracdes.html">descriptive statistics</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 3</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="summaryCh11.html">Summary SNASS chapter 11</a>
        </li>
        <li>
          <a href="webscraping_workshop.html">Workshop on webscraping</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 4</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="summaryCh12.html">Summary SNASS chapter 12</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 5</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="rSiena_dataprep.html">First introduction to dataprepping in rSiena</a>
        </li>
        <li>
          <a href="rSiena_prac_analyses.html">First introduction to analyses in rSiena</a>
        </li>
        <li>
          <a href="summaryCh8&amp;9.html">Summary SNASS chapter 8 and 9</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 6</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="summaryManualforSiena.html">Manual for RSiena</a>
        </li>
        <li>
          <a href="Descriptive_stats.html">First attempt at running descriptive statistics</a>
        </li>
      </ul>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Working documents project
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Introduction.html">Introduction</a>
    </li>
    <li>
      <a href="Theory.html">Theory</a>
    </li>
    <li>
      <a href="Methods.html">Methods</a>
    </li>
    <li>
      <a href="Results.html">Results</a>
    </li>
    <li>
      <a href="Conc_Disc.html">Conclusion and discussion</a>
    </li>
  </ul>
</li>
<li class="dropdown-header">Final Research project</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/StijnvanHelmondt/LabJournal">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Summary Chapter 8 and 9</h1>
<h4 class="author">by: Stijn van Helmondt</h4>

</div>


<div id="chapter-8" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Chapter 8</h1>
<div id="network-structures" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> 8.1 - Network
structures</h2>
<div id="path-length" class="section level3" number="1.1.1">
<h3><span class="header-section-number">1.1.1</span> 8.1.1 - Path
length</h3>
<p>Average shortest path –&gt; The average number of steps along the
shortest paths for all possible pairs of network nodes. Thus the length
of a path is the number of edges the path contains. Since path length
excludes disconnected nodes, it does not necessarily tells us something
about the ‘degrees of separation’. To do that, we will make use of the
function ego_size in the igraph package.</p>
<pre class="r"><code>mean((ego_size(random_graph, order = 2, mode = &quot;out&quot;) - 1)/vcount(random_graph))</code></pre>
<p>This brings us to the six-degrees-of-separation phenomenon. This is
the observation that for real societies and real worlds 100% of the
population would be connected to 100% of the population via 6 other
persons (making for a path length of seven). Phrased otherwise, with
path length seven, the average reach would be 100%. This is based on
Milgram’s (1967) ‘Small World’ study.</p>
</div>
<div id="cliques-and-communities" class="section level3" number="1.1.2">
<h3><span class="header-section-number">1.1.2</span> 8.1.2 - Cliques and
communities</h3>
<p>Not in the online version of SNASS</p>
</div>
<div id="segregation" class="section level3" number="1.1.3">
<h3><span class="header-section-number">1.1.3</span> 8.1.3 -
Segregation</h3>
<div id="inter--and-intragroup-density" class="section level4"
number="1.1.3.1">
<h4><span class="header-section-number">1.1.3.1</span> Inter- and
intragroup density</h4>
<p>Not in the online version of SNASS</p>
</div>
<div id="coleman" class="section level4" number="1.1.3.2">
<h4><span class="header-section-number">1.1.3.2</span> Coleman</h4>
<p>Not in the online version of SNASS</p>
</div>
<div id="morans-i" class="section level4" number="1.1.3.3">
<h4><span class="header-section-number">1.1.3.3</span> Moran’s I</h4>
<p>Inter-/intra group density and Coleman’s homophily measures describe
the extent to which similar people are more likely to be connected.
Moran’s I –&gt; We want to know if nodes who are closer to one another
in the network are more a like.</p>
<p>Start: A calculation of the correlation between the score of actor i
and the (mean) score of the alters of i to whom i is connected
directly.Spatial autocorrelation measures are actually quite complex. A
lot of build in functions in different packages of R are not very clear
on all the defaults. With respect to Moran’s I, its values are actually
quite difficult to compare across different spatial/network settings.
Results may depend heavily on whether or not you demean your variables
of interest, the chosen neighborhood/weight matrix (and hence on
distance decay functions and type of standardization of the weight
matrix). We need two packages, if we not want to define all functions
ourselves: sna and ape.</p>
<p>The SNA way:</p>
<pre class="r"><code>require(RSiena)
library(network)
friend.data.w1 &lt;- s501
friend.data.w2 &lt;- s502
friend.data.w3 &lt;- s503
drink &lt;- s50a
smoke &lt;- s50s

net1 &lt;- network::as.network(friend.data.w1)
net2 &lt;- network::as.network(friend.data.w2)
net3 &lt;- network::as.network(friend.data.w3)

# nacf does not row standardize!
snam1 &lt;- sna::nacf(net1, drink[, 1], type = &quot;moran&quot;, neighborhood.type = &quot;out&quot;, demean = TRUE)
snam1[2]  #the first order matrix is stored in second list-element</code></pre>
<p>The APE way:</p>
<pre class="r"><code>require(ape)
require(sna)
geodistances &lt;- geodist(net1, count.paths = TRUE)
geodistances &lt;- geodistances$gdist

# first define a nb based on distance 1.
weights1 &lt;- geodistances == 1

# this function rowstandardizes by default
ape::Moran.I(drink[, 1], scaled = FALSE, weight = weights1, na.rm = TRUE)</code></pre>
<p>Jochem’s way, without rowstandardizing</p>
<pre class="r"><code>fMoran.I &lt;- function(x, weight, scaled = FALSE, na.rm = FALSE, alternative = &quot;two.sided&quot;, rowstandardize = TRUE) {
    if (rowstandardize) {
        if (dim(weight)[1] != dim(weight)[2])
            stop(&quot;&#39;weight&#39; must be a square matrix&quot;)
        n &lt;- length(x)
        if (dim(weight)[1] != n)
            stop(&quot;&#39;weight&#39; must have as many rows as observations in &#39;x&#39;&quot;)
        ei &lt;- -1/(n - 1)
        nas &lt;- is.na(x)
        if (any(nas)) {
            if (na.rm) {
                x &lt;- x[!nas]
                n &lt;- length(x)
                weight &lt;- weight[!nas, !nas]
            } else {
                warning(&quot;&#39;x&#39; has missing values: maybe you wanted to set na.rm = TRUE?&quot;)
                return(list(observed = NA, expected = ei, sd = NA, p.value = NA))
            }
        }
        ROWSUM &lt;- rowSums(weight)
        ROWSUM[ROWSUM == 0] &lt;- 1
        weight &lt;- weight/ROWSUM
        s &lt;- sum(weight)
        m &lt;- mean(x)
        y &lt;- x - m
        cv &lt;- sum(weight * y %o% y)
        v &lt;- sum(y^2)
        obs &lt;- (n/s) * (cv/v)
        if (scaled) {
            i.max &lt;- (n/s) * (sd(rowSums(weight) * y)/sqrt(v/(n - 1)))
            obs &lt;- obs/i.max
        }
        S1 &lt;- 0.5 * sum((weight + t(weight))^2)
        S2 &lt;- sum((apply(weight, 1, sum) + apply(weight, 2, sum))^2)
        s.sq &lt;- s^2
        k &lt;- (sum(y^4)/n)/(v/n)^2
        sdi &lt;- sqrt((n * ((n^2 - 3 * n + 3) * S1 - n * S2 + 3 * s.sq) - k * (n * (n - 1) * S1 - 2 * n *
            S2 + 6 * s.sq))/((n - 1) * (n - 2) * (n - 3) * s.sq) - 1/((n - 1)^2))
        alternative &lt;- match.arg(alternative, c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;))
        pv &lt;- pnorm(obs, mean = ei, sd = sdi)
        if (alternative == &quot;two.sided&quot;)
            pv &lt;- if (obs &lt;= ei)
                2 * pv else 2 * (1 - pv)
        if (alternative == &quot;greater&quot;)
            pv &lt;- 1 - pv
        list(observed = obs, expected = ei, sd = sdi, p.value = pv)
    } else {
        if (dim(weight)[1] != dim(weight)[2])
            stop(&quot;&#39;weight&#39; must be a square matrix&quot;)
        n &lt;- length(x)
        if (dim(weight)[1] != n)
            stop(&quot;&#39;weight&#39; must have as many rows as observations in &#39;x&#39;&quot;)
        ei &lt;- -1/(n - 1)
        nas &lt;- is.na(x)
        if (any(nas)) {
            if (na.rm) {
                x &lt;- x[!nas]
                n &lt;- length(x)
                weight &lt;- weight[!nas, !nas]
            } else {
                warning(&quot;&#39;x&#39; has missing values: maybe you wanted to set na.rm = TRUE?&quot;)
                return(list(observed = NA, expected = ei, sd = NA, p.value = NA))
            }
        }
        # ROWSUM &lt;- rowSums(weight) ROWSUM[ROWSUM == 0] &lt;- 1 weight &lt;- weight/ROWSUM
        s &lt;- sum(weight)
        m &lt;- mean(x)
        y &lt;- x - m
        cv &lt;- sum(weight * y %o% y)
        v &lt;- sum(y^2)
        obs &lt;- (n/s) * (cv/v)
        if (scaled) {
            i.max &lt;- (n/s) * (sd(rowSums(weight) * y)/sqrt(v/(n - 1)))
            obs &lt;- obs/i.max
        }
        S1 &lt;- 0.5 * sum((weight + t(weight))^2)
        S2 &lt;- sum((apply(weight, 1, sum) + apply(weight, 2, sum))^2)
        s.sq &lt;- s^2
        k &lt;- (sum(y^4)/n)/(v/n)^2
        sdi &lt;- sqrt((n * ((n^2 - 3 * n + 3) * S1 - n * S2 + 3 * s.sq) - k * (n * (n - 1) * S1 - 2 * n *
            S2 + 6 * s.sq))/((n - 1) * (n - 2) * (n - 3) * s.sq) - 1/((n - 1)^2))
        alternative &lt;- match.arg(alternative, c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;))
        pv &lt;- pnorm(obs, mean = ei, sd = sdi)
        if (alternative == &quot;two.sided&quot;)
            pv &lt;- if (obs &lt;= ei)
                2 * pv else 2 * (1 - pv)
        if (alternative == &quot;greater&quot;)
            pv &lt;- 1 - pv
        list(observed = obs, expected = ei, sd = sdi, p.value = pv)
    }


}
fMoran.I(drink[, 1], scaled = FALSE, weight = weights1, na.rm = TRUE, rowstandardize = FALSE)</code></pre>
<p>Meaning of rowstandardization - rowstandardize: We assume that each
node i is influenced equally by its neighbourhood regardless on how
large it. You could compare this to the average alter effect in RSiena)
- not rowstandardize: We assume that each alter j has the same influence
on i (if at the same distance). You could compare this to the total
alter effect in RSiena.</p>
<p>To not standardize is default in sna::nacf, to standardize is default
in apa::Moran.I. Jochem Tolsma thus made a small adaption to
apa::Moran.I and now in the function fMoran.I you can choose if you want
to rowstandardize or not.</p>
<p>What I really would like to see is a correlation between actor i and
all the alters to whom it is connected (direct or indirectly) and where
alters at a larger distances (longer shortest path lengths) are weighted
less.</p>
<p>step 1: for each acter i determine the distances (shortest path
lengths) to all other nodes in the network.</p>
<pre class="r"><code># step 1: calculate distances
geodistances &lt;- geodist(net1, count.paths = TRUE)
geodistances &lt;- geodistances$gdist
# set the distance to yourself as Inf
diag(geodistances) &lt;- Inf</code></pre>
<p>step 2: based on these distances decide on how we want to weigh. That
is, determine a distance decay function.</p>
<pre class="r"><code># step 2: define a distance decay function. This one is pretty standard in the spatial autocorrelation literature but actually pretty arbitrary.
weights2 &lt;- exp(-geodistances)</code></pre>
<p>step 3: decide whether or not we want to row-standardize.</p>
<pre class="r"><code># step 3: I dont want to rowstandardize.
fMoran.I(drink[, 1], scaled = FALSE, weight = weights2, na.rm = TRUE, rowstandardize = FALSE)</code></pre>
<p>Conclusion: Yes pupils closer (have a shorter shortest path length)
to one another are more alike! You also observe that the correlation is
lower than we calculated previously. Apparently, we are alike to alters
very close by (path length one) and less so (or even dissimilar) to
alters further off.</p>
</div>
</div>
<div id="random-graphs" class="section level3" number="1.1.4">
<h3><span class="header-section-number">1.1.4</span> 8.2 - Random
graphs</h3>
<p>Now that we know how to count dyad and triad configurations, to
calculate network properties and to determine the extent of segregation
within networks, the follow-up question is: Is this a lot? Or even: Is
this significant? Let try to tackle the latter question. What do we mean
with significant? Probably something like: The chance, p, to observe our
value for network characteristic (or statistic), s(net), is smaller than
some arbitrary value, α, would we have randomly picked a network from
the general population of networks, X, to which our observed network,
xo, belongs.</p>
<p>This leaves us with just two smaller problems. First, what is this
population of networks to which our observed network belongs. Second,
what is the distribution of values for network characteristic s(net) in
this population?</p>
<p>In a small world network, despite having a low density and being
relatively clustered, the relative average path length is small. What do
we mean with relative? Well, in SNA it means that if we would make a
random graph, the chance is very low (lower than say 5%) that this graph
would have a higher degree of clustering and a shorter average path
length.</p>
<p>In igraph you can generate random graphs with the ‘erdos.renyi.game’
function. Let us make 1000 random graphs with size 105 (just as in
Smallworld) and with a density of 0.14 (just as in Smallworld). And let
us make a histogram of all observed average degree of clustering and
path lengths.</p>
<pre class="r"><code>require(igraph)
dens &lt;- round(graph.density(smallworld), 2)  #save density of smallworld
trial &lt;- 1000  #set number of trials/sims
trialclus &lt;- triallen &lt;- rep(NA, trial)  #define objects in which you are saving results


for (i in 1:trial) {
    random_graph &lt;- erdos.renyi.game(n = 105, p.or.m = dens, directed = FALSE)  #make the random graph
    triallen[i] &lt;- average.path.length(random_graph, unconnected = TRUE)  #calculate average path length
    trialclus[i] &lt;- transitivity(random_graph, isolates = c(&quot;NaN&quot;))  #calculate clustering
}


par(mfrow = c(1, 2))
{
    hist(trialclus, xlim = c(0.1, 0.36), main = &quot;average clustering coefficient&quot;, xlab = &quot;&quot;, )
    abline(v = transitivity(smallworld, isolates = c(&quot;NaN&quot;)), col = &quot;red&quot;, lwd = 3)
}

{
    hist(triallen, xlim = c(1.9, 2.2), main = &quot;average path length&quot;, xlab = &quot;&quot;)
    abline(v = average.path.length(smallworld, unconnected = TRUE), col = &quot;red&quot;, lwd = 3)
}</code></pre>
</div>
</div>
<div id="chapter-9-now-7---methods" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Chapter 9 (now 7) -
Methods</h2>
<p>There are many methods for analyzing the four theoretical dimensions
of social networks (i.e., size, composition, structure, evolution).</p>
<p>If we focus on the explanation of the micro-mechanisms that bring
about the structure of a social network, I would say there are two main
flavors within the social sciences: - Exponential-family Random Graph
Models: estimated for example with ergm - Stochastic Actor Orientated
Models: estimated for example with RSiena</p>
<p>Ideally, you should try to test your hypotheses with both methods.
And if results differ across models, try to understand why they do.</p>
<p>Why the focus is on RSiena: - We can use the micro-mechansism not
only to explain the evoluation of network structure but also of network
composition. Phrased otherwise, With this method (and the right type of
data) it is possible to distinguish between selection and influence
processes</p>
<div id="getting-started-with-setting-up-r" class="section level3"
number="1.2.1">
<h3><span class="header-section-number">1.2.1</span> Getting started
with setting up R</h3>
<pre class="r"><code>rm(list = ls())

fpackage.check &lt;- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

fsave &lt;- function(x, file = NULL, location = &quot;./data/processed/&quot;) {
    ifelse(!dir.exists(&quot;data&quot;), dir.create(&quot;data&quot;), FALSE)
    ifelse(!dir.exists(&quot;data/processed&quot;), dir.create(&quot;data/processed&quot;), FALSE)
    if (is.null(file))
        file = deparse(substitute(x))
    datename &lt;- substr(gsub(&quot;[:-]&quot;, &quot;&quot;, Sys.time()), 1, 8)
    totalname &lt;- paste(location, datename, file, &quot;.rda&quot;, sep = &quot;&quot;)
    save(x, file = totalname)  #need to fix if file is reloaded as input name, not as x. 
}

fload &lt;- function(filename) {
    load(filename)
    get(ls()[ls() != &quot;filename&quot;])
}

fshowdf &lt;- function(x, ...) {
    knitr::kable(x, digits = 2, &quot;html&quot;, ...) %&gt;%
        kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;)) %&gt;%
        kableExtra::scroll_box(width = &quot;100%&quot;, height = &quot;300px&quot;)
}

packages = c(&quot;RSiena&quot;, &quot;devtools&quot;, &quot;igraph&quot;)
fpackage.check(packages)
# devtools::install_github(&#39;JochemTolsma/RsienaTwoStep&#39;, build_vignettes=TRUE)
packages = c(&quot;RsienaTwoStep&quot;)
fpackage.check(packages)</code></pre>
</div>
<div id="rsiena-as-abm" class="section level3" number="1.2.2">
<h3><span class="header-section-number">1.2.2</span> 7.4 - RSiena as
ABM</h3>
<p>RSiena models the evolution of network structures and/or the behavior
of the social agents. It takes the current situation T0 as starting
point. It estimates the ‘rules’ for the agents how to change their ties
and/or behavior. If the model is specified correctly, these rules (or
micro mechanisms) have led the situation at T0 to evolve into the
situation observed at T1.</p>
<p>What does RSiena do and not do? - No re-activity: The act of
re-affirming, making or breaking an outgoing tie does not trigger a
response by the involved alter - No simultaneity: Changes occur one by
one - Hence also no cooperation, coordination or negotiation - No
maximization of total utility: + No altruistic behavior: Individual
utility is maximized, not total utility - No strategic behavior + Very
finite time horizon. Agent does not predict how his/her future local
network neighborhood may change after: - Making another ministep
him/herself - A ministep of other agents + Hence also no investments</p>
<p>This does not mean that RSiena cannot estimate (or better: ‘fit’) the
evolution of networks/behavior that are the consequences of these more
complex ‘rules’ or micro theories but it assumes actors only make
ministeps.</p>
</div>
<div id="simulation-logic" class="section level3" number="1.2.3">
<h3><span class="header-section-number">1.2.3</span> 7.5 - Simulation
logic</h3>
<ul>
<li>Sample ego</li>
<li>Construct possible alternative future networks based on all possible
ministeps of ego</li>
<li>Calculate how sampled ego evaluates these possible networks</li>
<li>Let the ego pick a network, that is, let agent decide on a
tie-change</li>
<li>GOTO 1 (STOPPING RULE: until you think we have made enough
ministeps)</li>
</ul>
<div id="sampling-an-ego" class="section level4" number="1.2.3.1">
<h4><span class="header-section-number">1.2.3.1</span> 7.5.1 - Sampling
an ego</h4>
<pre class="r"><code>net1

# Plotting net1

net1g &lt;- graph_from_adjacency_matrix(net1, mode = &quot;directed&quot;)
coords &lt;- layout_(net1g, nicely())  #let us keep the layout
par(mar = c(0.1, 0.1, 0.1, 0.1))
{
    plot.igraph(net1g, layout = coords)
    graphics::box()
}</code></pre>
<p>So only one actor is allowed to make one ministep. But who? This is
determined by the rate function and it may depend on ego-characteristics
of our social agents (e.g. male/female) and/or on
structural-characteristics of our social agents (e.g. indegree,
outdegree). And all this can be estimated within RSiena. More often than
note, we simply assume that all actors have an equal chance of being
selected to make a ministep.</p>
<p>For more information on the rate function see (ref:#rp).</p>
<p>Okay, we can thus randomly select/sample an agent.</p>
<pre class="r"><code>set.seed(24553253)
ego &lt;- ts_select(net = net1, steps = 1)  #in rsienatwostep two actors may make a change together but here not
ego</code></pre>
</div>
<div id="possible-networks-after-ministep" class="section level4"
number="1.2.3.2">
<h4><span class="header-section-number">1.2.3.2</span> 7.5.2 - Possible
networks after ministep</h4>
<p>Let us suppose we want to know what the possible networks are after
all possible ministeps of ego who is part of net1. That is, let us
assume that it is ego’s turn (ego#: 4) to decide on tie-change. What are
the possible networks?</p>
<p>The function ts_alternatives_ministep() returns a list of all
possible networks after all possible tie-changes available to an ego
given network da network.</p>
<pre class="r"><code>options &lt;- ts_alternatives_ministep(net = net1, ego = ego)
options
plots &lt;- lapply(options, graph_from_adjacency_matrix, mode = &quot;directed&quot;)
par(mar = c(0, 0, 0, 0) + 0.1)
par(mfrow = c(2, 2))

fplot &lt;- function(x) {
    plot.igraph(x, layout = coords, margin = 0)
    graphics::box()
}

lapply(plots, fplot)</code></pre>
</div>
<div id="network-statistics" class="section level4" number="1.2.3.3">
<h4><span class="header-section-number">1.2.3.3</span> 7.5.3 - Network
statistics</h4>
<p>The option an ego will choose depends on which network
characteristics (or statistics) ego finds relevant. Let us suppose that
ego bases its decision solely on the number of ties it sends to others
and the number of reciprocated ties it has with others.</p>
<p>First: count the outdegree</p>
<pre class="r"><code>ts_degree(net = options[[1]], ego = ego)

# or for all options

lapply(options, ts_degree, ego = ego)</code></pre>
<p>Then count the number of reciprocated ties</p>
<pre class="r"><code>lapply(options, ts_recip, ego = ego)</code></pre>
<p>Network statistics in the package ‘RsienaTwoStep’:</p>
<ul>
<li>degree: ts_degree()</li>
<li>reciprocity: ts_recip()</li>
<li>outdegree activity: ts_outAct()</li>
<li>indegree activity: ts_inAct()</li>
<li>outdegree popularity: ts_outPop()</li>
<li>indegree popularity: ts_inPop()</li>
<li>transitivity: ts_transTrip()</li>
<li>mediated transitivity: ts_transMedTrip()</li>
<li>transitive reciprocated triplets: ts_transRecTrip()</li>
<li>number of three-cycles: ts_cycle3()</li>
</ul>
</div>
<div id="evaluation-function" class="section level4" number="1.2.3.4">
<h4><span class="header-section-number">1.2.3.4</span> 7.5.4 -
Evaluation function</h4>
<p>But what evaluation value does ego attach to these network statistics
and consequently to the network (in its vicinity) as a whole? Well these
are the parameters, βi, you will normally estimate with
RSiena::siena07(). Let us suppose the importance for:</p>
<ul>
<li>the statistic ‘degree’, β1, is -1</li>
<li>for the statistic ‘reciprocity’, β2, is 1.5.</li>
</ul>
<pre class="r"><code>option &lt;- 4
ts_degree(options[[option]], ego = ego) * -1 + ts_recip(options[[option]], ego = ego) * 1.5

# Or use as ts_eval()

eval &lt;- ts_eval(net = options[[option]], ego = ego, statistics = list(ts_degree, ts_recip), parameters = c(-1,
    1.5))
eval</code></pre>
<p>Now, let’s calculate the evaluation of all possible networks:</p>
<pre class="r"><code>eval &lt;- sapply(options, FUN = ts_eval, ego = ego, statistics = list(ts_degree, ts_recip), parameters = c(-1,
    1.5))
eval
print(&quot;network with maximum evaluation score:&quot;)
which.max(eval)</code></pre>
</div>
<div id="choice-function" class="section level4" number="1.2.3.5">
<h4><span class="header-section-number">1.2.3.5</span> 7.5.5 - Choice
function</h4>
<p>So which option will ego choose? Naturally this will be a stochastic
process. But we see that option 4 has the highest evaluation. Forcing
ego to make a decision:</p>
<pre class="r"><code>choice &lt;- sample(1:length(eval), size = 1, prob = exp(eval)/sum(exp(eval)))
print(&quot;choice:&quot;)
choice
# print(&#39;network:&#39;) options[[choice]]</code></pre>
<p>If we repeat this process we have an agent based model The process: -
sample agent - construct possible alternative networks - calculate how
sampled agent evaluates the possible networks - Let the agent pick a
network, that is, let agent decide on a tie-change - GO BACK TO 1
(STOPPING RULE: until you think we have made enough ministeps)</p>
</div>
<div id="stopping-rule" class="section level4" number="1.2.3.6">
<h4><span class="header-section-number">1.2.3.6</span> 7.5.6 - Stopping
rule</h4>
<p>But how many ministeps do we allow? Well, normally this is estimated
by siena07 by the rate parameter. If we do not make this rate parameter
conditional on actor covariates or on network characteristics, the rate
parameter can be interpreted as the average number of ministeps each
actor in the network is allowed to make before time is up. Let us
suppose the rate parameter is 2 . Thus in total the number of possible
ministeps will be nrow(net1)*rate: 20.</p>
</div>
</div>
<div id="simulation-example" class="section level3" number="1.2.4">
<h3><span class="header-section-number">1.2.4</span> 7.6 - Simulation
example</h3>
<p>Let us now simulate how the network could evolve given:</p>
<ul>
<li>starting point is net1</li>
<li>rate is set to 2</li>
<li>we as scientists think only network statistics degree and
reciprocity are important</li>
<li>RSiena::siena07 has determined the parameters for these statistics
are -1 and 1.5 respectively</li>
<li>We adhere to the ministep assumption and hence set p2step to
c(1,0,0)</li>
</ul>
<pre class="r"><code>ts_sims(nsims = 1, net = net1, rate = 2, statistics = list(ts_degree, ts_recip), parameters = c(-1, 1.5),
    p2step = c(1, 0, 0), chain = FALSE)</code></pre>
</div>
<div id="estimation-logic" class="section level3" number="1.2.5">
<h3><span class="header-section-number">1.2.5</span> 7.7 Estimation
logic</h3>
<p>Estimation procedure in RSiena: - Define model: researcher includes
effects - initial parameter values of effects (commonly ‘0’) - simulate
an outcome network based on these parameter values - compare the network
statistics of the simulated outcome network with the observed outcome
network (i.e. the target values) + based on the included effects. Thus
the simulated network may contain 10 ties, but the observed network may
contain 20 ties. Apparently, with the current parameter values we
underestimate the density of the outcome network. - tweak/update
parameter values in some smart way - GOTO 3 (BREAK RULE: until parameter
values cannot be improved anymore / or reached good fit) - simulate a
bunch of outcome networks with the obtained parameter values and compare
the expected values of statistics of the outcome networks with the
target values. + we can assess the fit + estimate SE of the
parameters</p>
</div>
<div id="interpretation-of-parameters" class="section level3"
number="1.2.6">
<h3><span class="header-section-number">1.2.6</span> 7.8 Interpretation
of parameters</h3>
<div id="rate-parameter" class="section level4" number="1.2.6.1">
<h4><span class="header-section-number">1.2.6.1</span> 7.8.1 - Rate
parameter</h4>
<p>estimated rate parameter –&gt; the expected number of opportunities
for change per actor in a time period.</p>
<p>Suppose we have three actors: i, j and k. And suppose that the rate
function is a constant, thus the rate function does not depend on the
network structure or attributes of the actors. Thus suppose for
example:</p>
<p>λi = 5 λj = 10 λk = 15</p>
<p>The waiting times of actors i, j and k are exponentially distributed
with rate parameter λ. The exponential distribution looks like:</p>
<pre class="r"><code>par(mfrow = c(1, 3))

dist_5 &lt;- rexp(10000, rate = 5)
hist(dist_5, main = &quot;rate = lambda_i = 5&quot;, freq = FALSE, xlab = &quot;waiting times&quot;, xlim = c(0, 2), ylim = c(0,
    9))
abline(v = 1/5, col = &quot;red&quot;)

dist_10 &lt;- rexp(10000, rate = 10)
hist(dist_10, main = &quot;rate= lambda_j = 10&quot;, freq = FALSE, xlab = &quot;waiting times&quot;, xlim = c(0, 2), ylim = c(0,
    9))
abline(v = 1/10, col = &quot;red&quot;)

dist_15 &lt;- rexp(10000, rate = 15)
hist(dist_10, main = &quot;rate = lambda_k = 15&quot;, freq = FALSE, xlab = &quot;waiting times&quot;, xlim = c(0, 2), ylim = c(0,
    9))
abline(v = 1/15, col = &quot;red&quot;)</code></pre>
<p>Determining which actor is allowed to do a next ministep: sample a
waiting time for each actor. Thus each actor gets a waiting time sampled
from the exponential distribution with the specified rate parameter:</p>
<pre class="r"><code>set.seed(34641)
waitingtimes &lt;- NA
waitingtimes[1] &lt;- rexp(1, rate = 5)
waitingtimes[2] &lt;- rexp(1, rate = 10)
waitingtimes[3] &lt;- rexp(1, rate = 15)
print(paste(&quot;waitingtime_&quot;, c(&quot;i: &quot;, &quot;j: &quot;, &quot;k: &quot;), round(waitingtimes, 3), sep = &quot;&quot;))</code></pre>
<p>Repeat this process of determining who is allowed to take a ministep
a couple of times and keep track of who will make the ministep and the
time that has passed:</p>
<pre class="r"><code>set.seed(245651)
sam_waitingtimes &lt;- NA
time &lt;- 0
for (ministeps in 1:50) {
    waitingtimes &lt;- NA
    waitingtimes[1] &lt;- rexp(1, rate = 5)
    waitingtimes[2] &lt;- rexp(1, rate = 10)
    waitingtimes[3] &lt;- rexp(1, rate = 15)
    actor &lt;- which(waitingtimes == min(waitingtimes))
    time &lt;- time + waitingtimes[actor]
    sam_waitingtimes[ministeps] &lt;- waitingtimes[actor]
    print(paste(&quot;ministep nr.: &quot;, ministeps, sep = &quot;&quot;))
    print(paste(&quot;waitingtime_&quot;, c(&quot;i: &quot;, &quot;j: &quot;, &quot;k: &quot;)[actor], round(waitingtimes, 3)[actor], sep = &quot;&quot;))
    print(paste(&quot;time past: &quot;, round(time, 3), sep = &quot;&quot;))
}</code></pre>
<p>Plot the sampled waiting times:</p>
<pre class="r"><code>set.seed(245651)
sam_waitingtimes &lt;- NA
for (ministeps in 1:5000) {
    waitingtimes &lt;- NA
    waitingtimes[1] &lt;- rexp(1, rate = 5)
    waitingtimes[2] &lt;- rexp(1, rate = 10)
    waitingtimes[3] &lt;- rexp(1, rate = 15)
    actor &lt;- which(waitingtimes == min(waitingtimes))
    sam_waitingtimes[ministeps] &lt;- waitingtimes[actor]
}

par(mfrow = c(1, 2))
hist(sam_waitingtimes, freq = FALSE, xlab = &quot;waiting times&quot;, main = &quot;sampled waiting times&quot;)
abline(v = mean(sam_waitingtimes), col = &quot;red&quot;)

hist(rexp(5000, rate = 30), freq = FALSE, xlab = &quot;waiting times&quot;, main = &quot;rate=30&quot;)
abline(v = 1/30, col = &quot;red&quot;)</code></pre>
<p>If an actor has a higher rate parameter, the expected sampled waiting
time is shorter. And since the actor with the shortest waiting time will
make the ministep, actors with the highest rate parameter have the
highest probability to have an opportunity for change –&gt; the larger
the rate parameter the more opportunities for change there are within a
given time period.</p>
<p>Plotting the # of ministeps required to surpass ‘1’ over 1000
samples:</p>
<pre class="r"><code>set.seed(245651)

results &lt;- list()
for (nsim in 1:1000) {
    time &lt;- 0
    steps_tot &lt;- 0
    steps_i &lt;- 0
    steps_j &lt;- 0
    steps_k &lt;- 0
    actors &lt;- NA
    while (time &lt; 1) {
        steps_tot &lt;- steps_tot + 1
        waitingtimes &lt;- NA
        waitingtimes[1] &lt;- rexp(1, rate = 5)
        waitingtimes[2] &lt;- rexp(1, rate = 10)
        waitingtimes[3] &lt;- rexp(1, rate = 15)
        actor &lt;- which(waitingtimes == min(waitingtimes))
        time &lt;- time + waitingtimes[actor]
        actors[steps_tot] &lt;- actor
    }
    results[[nsim]] &lt;- actors
}

# sum(results[[1]]==1) hist(sapply(results, length))

par(mfrow = c(1, 3))
{
    hist(sapply(results, function(x) {
        sum(x == 1)
    }), xlab = &quot;nsteps&quot;, main = &quot;actor i: lambda=5&quot;)
    abline(v = mean(sapply(results, function(x) {
        sum(x == 1)
    })), col = &quot;red&quot;)
}

{
    hist(sapply(results, function(x) {
        sum(x == 2)
    }), xlab = &quot;nsteps&quot;, main = &quot;actor j: lambda=10&quot;)
    abline(v = mean(sapply(results, function(x) {
        sum(x == 2)
    })), col = &quot;red&quot;)
}

{
    hist(sapply(results, function(x) {
        sum(x == 3)
    }), xlab = &quot;nsteps&quot;, main = &quot;actor k: lambda=15&quot;)
    abline(v = mean(sapply(results, function(x) {
        sum(x == 3)
    })), col = &quot;red&quot;)
}</code></pre>
<p>Conclusion: the larger the rate parameter the more opportunities for
change per actor there are within a given time period. And in RSiena the
optimal value for the rate parameter λi is estimated. The estimated
parameter has a nice interpretation: the estimated rate parameter refers
to the expected number of opportunities for change in a time period.</p>
</div>
</div>
</div>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlN1bW1hcnkgQ2hhcHRlciA4IGFuZCA5Ig0Kb3V0cHV0Og0KICBodG1sX2RvY3VtZW50Og0KICAgIHRvYzogdHJ1ZQ0KICAgIG51bWJlcl9zZWN0aW9uczogdHJ1ZQ0KYXV0aG9yOiAiYnk6IFN0aWpuIHZhbiBIZWxtb25kdCINCmJpYmxpb2dyYXBoeTogcmVmZXJlbmNlcy5iaWINCi0tLQ0KDQojIENoYXB0ZXIgOA0KDQojIyA4LjEgLSBOZXR3b3JrIHN0cnVjdHVyZXMNCg0KIyMjIDguMS4xIC0gUGF0aCBsZW5ndGgNCg0KQXZlcmFnZSBzaG9ydGVzdCBwYXRoIC0tPiAgVGhlIGF2ZXJhZ2UgbnVtYmVyIG9mIHN0ZXBzIGFsb25nIHRoZSBzaG9ydGVzdCBwYXRocyBmb3IgYWxsIHBvc3NpYmxlIHBhaXJzIG9mIG5ldHdvcmsgbm9kZXMuIFRodXMgdGhlIGxlbmd0aCBvZiBhIHBhdGggaXMgdGhlIG51bWJlciBvZiBlZGdlcyB0aGUgcGF0aCBjb250YWlucy4gU2luY2UgcGF0aCBsZW5ndGggZXhjbHVkZXMgZGlzY29ubmVjdGVkIG5vZGVzLCBpdCBkb2VzIG5vdCBuZWNlc3NhcmlseSB0ZWxscyB1cyBzb21ldGhpbmcgYWJvdXQgdGhlIOKAmGRlZ3JlZXMgb2Ygc2VwYXJhdGlvbicuIFRvIGRvIHRoYXQsIHdlIHdpbGwgbWFrZSB1c2Ugb2YgdGhlIGZ1bmN0aW9uIGVnb19zaXplIGluIHRoZSBpZ3JhcGggcGFja2FnZS4NCg0KYGBge3IsIGV2YWw9RkFMU0V9DQptZWFuKChlZ29fc2l6ZShyYW5kb21fZ3JhcGgsIG9yZGVyID0gMiwgbW9kZSA9ICJvdXQiKSAtIDEpL3Zjb3VudChyYW5kb21fZ3JhcGgpKQ0KYGBgDQoNClRoaXMgYnJpbmdzIHVzIHRvIHRoZSBzaXgtZGVncmVlcy1vZi1zZXBhcmF0aW9uIHBoZW5vbWVub24uIFRoaXMgaXMgdGhlIG9ic2VydmF0aW9uIHRoYXQgZm9yIHJlYWwgc29jaWV0aWVzIGFuZCByZWFsIHdvcmxkcyAxMDAlIG9mIHRoZSBwb3B1bGF0aW9uIHdvdWxkIGJlIGNvbm5lY3RlZCB0byAxMDAlIG9mIHRoZSBwb3B1bGF0aW9uIHZpYSA2IG90aGVyIHBlcnNvbnMgKG1ha2luZyBmb3IgYSBwYXRoIGxlbmd0aCBvZiBzZXZlbikuIFBocmFzZWQgb3RoZXJ3aXNlLCB3aXRoIHBhdGggbGVuZ3RoIHNldmVuLCB0aGUgYXZlcmFnZSByZWFjaCB3b3VsZCBiZSAxMDAlLiBUaGlzIGlzIGJhc2VkIG9uIE1pbGdyYW0ncyAoMTk2NykgJ1NtYWxsIFdvcmxkJyBzdHVkeS4NCg0KIyMjIDguMS4yIC0gQ2xpcXVlcyBhbmQgY29tbXVuaXRpZXMgDQoNCk5vdCBpbiB0aGUgb25saW5lIHZlcnNpb24gb2YgU05BU1MNCg0KIyMjIDguMS4zIC0gU2VncmVnYXRpb24gDQoNCiMjIyMgSW50ZXItIGFuZCBpbnRyYWdyb3VwIGRlbnNpdHkgDQoNCk5vdCBpbiB0aGUgb25saW5lIHZlcnNpb24gb2YgU05BU1MNCg0KIyMjIyBDb2xlbWFuDQoNCk5vdCBpbiB0aGUgb25saW5lIHZlcnNpb24gb2YgU05BU1MNCg0KIyMjIyBNb3JhbidzIEkNCg0KSW50ZXItL2ludHJhIGdyb3VwIGRlbnNpdHkgYW5kIENvbGVtYW7igJlzIGhvbW9waGlseSBtZWFzdXJlcyBkZXNjcmliZSB0aGUgZXh0ZW50IHRvIHdoaWNoIHNpbWlsYXIgcGVvcGxlIGFyZSBtb3JlIGxpa2VseSB0byBiZSBjb25uZWN0ZWQuIE1vcmFuJ3MgSSAtLT4gV2Ugd2FudCB0byBrbm93IGlmIG5vZGVzIHdobyBhcmUgY2xvc2VyIHRvIG9uZSBhbm90aGVyIGluIHRoZSBuZXR3b3JrIGFyZSBtb3JlIGEgbGlrZS4gDQoNClN0YXJ0OiBBIGNhbGN1bGF0aW9uIG9mIHRoZSBjb3JyZWxhdGlvbiBiZXR3ZWVuIHRoZSBzY29yZSBvZiBhY3RvciBpIGFuZCB0aGUgKG1lYW4pIHNjb3JlIG9mIHRoZSBhbHRlcnMgb2YgaSB0byB3aG9tIGkgaXMgY29ubmVjdGVkIGRpcmVjdGx5LlNwYXRpYWwgYXV0b2NvcnJlbGF0aW9uIG1lYXN1cmVzIGFyZSBhY3R1YWxseSBxdWl0ZSBjb21wbGV4LiBBIGxvdCBvZiBidWlsZCBpbiBmdW5jdGlvbnMgaW4gZGlmZmVyZW50IHBhY2thZ2VzIG9mIFIgYXJlIG5vdCB2ZXJ5IGNsZWFyIG9uIGFsbCB0aGUgZGVmYXVsdHMuIFdpdGggcmVzcGVjdCB0byBNb3JhbuKAmXMgSSwgaXRzIHZhbHVlcyBhcmUgYWN0dWFsbHkgcXVpdGUgZGlmZmljdWx0IHRvIGNvbXBhcmUgYWNyb3NzIGRpZmZlcmVudCBzcGF0aWFsL25ldHdvcmsgc2V0dGluZ3MuIFJlc3VsdHMgbWF5IGRlcGVuZCBoZWF2aWx5IG9uIHdoZXRoZXIgb3Igbm90IHlvdSBkZW1lYW4geW91ciB2YXJpYWJsZXMgb2YgaW50ZXJlc3QsIHRoZSBjaG9zZW4gbmVpZ2hib3Job29kL3dlaWdodCBtYXRyaXggKGFuZCBoZW5jZSBvbiBkaXN0YW5jZSBkZWNheSBmdW5jdGlvbnMgYW5kIHR5cGUgb2Ygc3RhbmRhcmRpemF0aW9uIG9mIHRoZSB3ZWlnaHQgbWF0cml4KS4gV2UgbmVlZCB0d28gcGFja2FnZXMsIGlmIHdlIG5vdCB3YW50IHRvIGRlZmluZSBhbGwgZnVuY3Rpb25zIG91cnNlbHZlczogc25hIGFuZCBhcGUuDQoNClRoZSBTTkEgd2F5Og0KYGBge3IsIGV2YWw9RkFMU0V9DQpyZXF1aXJlKFJTaWVuYSkNCmxpYnJhcnkobmV0d29yaykNCmZyaWVuZC5kYXRhLncxIDwtIHM1MDENCmZyaWVuZC5kYXRhLncyIDwtIHM1MDINCmZyaWVuZC5kYXRhLnczIDwtIHM1MDMNCmRyaW5rIDwtIHM1MGENCnNtb2tlIDwtIHM1MHMNCg0KbmV0MSA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGZyaWVuZC5kYXRhLncxKQ0KbmV0MiA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGZyaWVuZC5kYXRhLncyKQ0KbmV0MyA8LSBuZXR3b3JrOjphcy5uZXR3b3JrKGZyaWVuZC5kYXRhLnczKQ0KDQojIG5hY2YgZG9lcyBub3Qgcm93IHN0YW5kYXJkaXplIQ0Kc25hbTEgPC0gc25hOjpuYWNmKG5ldDEsIGRyaW5rWywgMV0sIHR5cGUgPSAibW9yYW4iLCBuZWlnaGJvcmhvb2QudHlwZSA9ICJvdXQiLCBkZW1lYW4gPSBUUlVFKQ0Kc25hbTFbMl0gICN0aGUgZmlyc3Qgb3JkZXIgbWF0cml4IGlzIHN0b3JlZCBpbiBzZWNvbmQgbGlzdC1lbGVtZW50DQpgYGANCg0KVGhlIEFQRSB3YXk6DQpgYGB7ciwgZXZhbD1GQUxTRX0NCnJlcXVpcmUoYXBlKQ0KcmVxdWlyZShzbmEpDQpnZW9kaXN0YW5jZXMgPC0gZ2VvZGlzdChuZXQxLCBjb3VudC5wYXRocyA9IFRSVUUpDQpnZW9kaXN0YW5jZXMgPC0gZ2VvZGlzdGFuY2VzJGdkaXN0DQoNCiMgZmlyc3QgZGVmaW5lIGEgbmIgYmFzZWQgb24gZGlzdGFuY2UgMS4NCndlaWdodHMxIDwtIGdlb2Rpc3RhbmNlcyA9PSAxDQoNCiMgdGhpcyBmdW5jdGlvbiByb3dzdGFuZGFyZGl6ZXMgYnkgZGVmYXVsdA0KYXBlOjpNb3Jhbi5JKGRyaW5rWywgMV0sIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSB3ZWlnaHRzMSwgbmEucm0gPSBUUlVFKQ0KYGBgDQoNCkpvY2hlbSdzIHdheSwgd2l0aG91dCByb3dzdGFuZGFyZGl6aW5nDQpgYGB7ciwgZXZhbD1GQUxTRX0NCmZNb3Jhbi5JIDwtIGZ1bmN0aW9uKHgsIHdlaWdodCwgc2NhbGVkID0gRkFMU0UsIG5hLnJtID0gRkFMU0UsIGFsdGVybmF0aXZlID0gInR3by5zaWRlZCIsIHJvd3N0YW5kYXJkaXplID0gVFJVRSkgew0KICAgIGlmIChyb3dzdGFuZGFyZGl6ZSkgew0KICAgICAgICBpZiAoZGltKHdlaWdodClbMV0gIT0gZGltKHdlaWdodClbMl0pDQogICAgICAgICAgICBzdG9wKCInd2VpZ2h0JyBtdXN0IGJlIGEgc3F1YXJlIG1hdHJpeCIpDQogICAgICAgIG4gPC0gbGVuZ3RoKHgpDQogICAgICAgIGlmIChkaW0od2VpZ2h0KVsxXSAhPSBuKQ0KICAgICAgICAgICAgc3RvcCgiJ3dlaWdodCcgbXVzdCBoYXZlIGFzIG1hbnkgcm93cyBhcyBvYnNlcnZhdGlvbnMgaW4gJ3gnIikNCiAgICAgICAgZWkgPC0gLTEvKG4gLSAxKQ0KICAgICAgICBuYXMgPC0gaXMubmEoeCkNCiAgICAgICAgaWYgKGFueShuYXMpKSB7DQogICAgICAgICAgICBpZiAobmEucm0pIHsNCiAgICAgICAgICAgICAgICB4IDwtIHhbIW5hc10NCiAgICAgICAgICAgICAgICBuIDwtIGxlbmd0aCh4KQ0KICAgICAgICAgICAgICAgIHdlaWdodCA8LSB3ZWlnaHRbIW5hcywgIW5hc10NCiAgICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICAgICAgd2FybmluZygiJ3gnIGhhcyBtaXNzaW5nIHZhbHVlczogbWF5YmUgeW91IHdhbnRlZCB0byBzZXQgbmEucm0gPSBUUlVFPyIpDQogICAgICAgICAgICAgICAgcmV0dXJuKGxpc3Qob2JzZXJ2ZWQgPSBOQSwgZXhwZWN0ZWQgPSBlaSwgc2QgPSBOQSwgcC52YWx1ZSA9IE5BKSkNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICBST1dTVU0gPC0gcm93U3Vtcyh3ZWlnaHQpDQogICAgICAgIFJPV1NVTVtST1dTVU0gPT0gMF0gPC0gMQ0KICAgICAgICB3ZWlnaHQgPC0gd2VpZ2h0L1JPV1NVTQ0KICAgICAgICBzIDwtIHN1bSh3ZWlnaHQpDQogICAgICAgIG0gPC0gbWVhbih4KQ0KICAgICAgICB5IDwtIHggLSBtDQogICAgICAgIGN2IDwtIHN1bSh3ZWlnaHQgKiB5ICVvJSB5KQ0KICAgICAgICB2IDwtIHN1bSh5XjIpDQogICAgICAgIG9icyA8LSAobi9zKSAqIChjdi92KQ0KICAgICAgICBpZiAoc2NhbGVkKSB7DQogICAgICAgICAgICBpLm1heCA8LSAobi9zKSAqIChzZChyb3dTdW1zKHdlaWdodCkgKiB5KS9zcXJ0KHYvKG4gLSAxKSkpDQogICAgICAgICAgICBvYnMgPC0gb2JzL2kubWF4DQogICAgICAgIH0NCiAgICAgICAgUzEgPC0gMC41ICogc3VtKCh3ZWlnaHQgKyB0KHdlaWdodCkpXjIpDQogICAgICAgIFMyIDwtIHN1bSgoYXBwbHkod2VpZ2h0LCAxLCBzdW0pICsgYXBwbHkod2VpZ2h0LCAyLCBzdW0pKV4yKQ0KICAgICAgICBzLnNxIDwtIHNeMg0KICAgICAgICBrIDwtIChzdW0oeV40KS9uKS8odi9uKV4yDQogICAgICAgIHNkaSA8LSBzcXJ0KChuICogKChuXjIgLSAzICogbiArIDMpICogUzEgLSBuICogUzIgKyAzICogcy5zcSkgLSBrICogKG4gKiAobiAtIDEpICogUzEgLSAyICogbiAqDQogICAgICAgICAgICBTMiArIDYgKiBzLnNxKSkvKChuIC0gMSkgKiAobiAtIDIpICogKG4gLSAzKSAqIHMuc3EpIC0gMS8oKG4gLSAxKV4yKSkNCiAgICAgICAgYWx0ZXJuYXRpdmUgPC0gbWF0Y2guYXJnKGFsdGVybmF0aXZlLCBjKCJ0d28uc2lkZWQiLCAibGVzcyIsICJncmVhdGVyIikpDQogICAgICAgIHB2IDwtIHBub3JtKG9icywgbWVhbiA9IGVpLCBzZCA9IHNkaSkNCiAgICAgICAgaWYgKGFsdGVybmF0aXZlID09ICJ0d28uc2lkZWQiKQ0KICAgICAgICAgICAgcHYgPC0gaWYgKG9icyA8PSBlaSkNCiAgICAgICAgICAgICAgICAyICogcHYgZWxzZSAyICogKDEgLSBwdikNCiAgICAgICAgaWYgKGFsdGVybmF0aXZlID09ICJncmVhdGVyIikNCiAgICAgICAgICAgIHB2IDwtIDEgLSBwdg0KICAgICAgICBsaXN0KG9ic2VydmVkID0gb2JzLCBleHBlY3RlZCA9IGVpLCBzZCA9IHNkaSwgcC52YWx1ZSA9IHB2KQ0KICAgIH0gZWxzZSB7DQogICAgICAgIGlmIChkaW0od2VpZ2h0KVsxXSAhPSBkaW0od2VpZ2h0KVsyXSkNCiAgICAgICAgICAgIHN0b3AoIid3ZWlnaHQnIG11c3QgYmUgYSBzcXVhcmUgbWF0cml4IikNCiAgICAgICAgbiA8LSBsZW5ndGgoeCkNCiAgICAgICAgaWYgKGRpbSh3ZWlnaHQpWzFdICE9IG4pDQogICAgICAgICAgICBzdG9wKCInd2VpZ2h0JyBtdXN0IGhhdmUgYXMgbWFueSByb3dzIGFzIG9ic2VydmF0aW9ucyBpbiAneCciKQ0KICAgICAgICBlaSA8LSAtMS8obiAtIDEpDQogICAgICAgIG5hcyA8LSBpcy5uYSh4KQ0KICAgICAgICBpZiAoYW55KG5hcykpIHsNCiAgICAgICAgICAgIGlmIChuYS5ybSkgew0KICAgICAgICAgICAgICAgIHggPC0geFshbmFzXQ0KICAgICAgICAgICAgICAgIG4gPC0gbGVuZ3RoKHgpDQogICAgICAgICAgICAgICAgd2VpZ2h0IDwtIHdlaWdodFshbmFzLCAhbmFzXQ0KICAgICAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICAgICAgICB3YXJuaW5nKCIneCcgaGFzIG1pc3NpbmcgdmFsdWVzOiBtYXliZSB5b3Ugd2FudGVkIHRvIHNldCBuYS5ybSA9IFRSVUU/IikNCiAgICAgICAgICAgICAgICByZXR1cm4obGlzdChvYnNlcnZlZCA9IE5BLCBleHBlY3RlZCA9IGVpLCBzZCA9IE5BLCBwLnZhbHVlID0gTkEpKQ0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgICMgUk9XU1VNIDwtIHJvd1N1bXMod2VpZ2h0KSBST1dTVU1bUk9XU1VNID09IDBdIDwtIDEgd2VpZ2h0IDwtIHdlaWdodC9ST1dTVU0NCiAgICAgICAgcyA8LSBzdW0od2VpZ2h0KQ0KICAgICAgICBtIDwtIG1lYW4oeCkNCiAgICAgICAgeSA8LSB4IC0gbQ0KICAgICAgICBjdiA8LSBzdW0od2VpZ2h0ICogeSAlbyUgeSkNCiAgICAgICAgdiA8LSBzdW0oeV4yKQ0KICAgICAgICBvYnMgPC0gKG4vcykgKiAoY3YvdikNCiAgICAgICAgaWYgKHNjYWxlZCkgew0KICAgICAgICAgICAgaS5tYXggPC0gKG4vcykgKiAoc2Qocm93U3Vtcyh3ZWlnaHQpICogeSkvc3FydCh2LyhuIC0gMSkpKQ0KICAgICAgICAgICAgb2JzIDwtIG9icy9pLm1heA0KICAgICAgICB9DQogICAgICAgIFMxIDwtIDAuNSAqIHN1bSgod2VpZ2h0ICsgdCh3ZWlnaHQpKV4yKQ0KICAgICAgICBTMiA8LSBzdW0oKGFwcGx5KHdlaWdodCwgMSwgc3VtKSArIGFwcGx5KHdlaWdodCwgMiwgc3VtKSleMikNCiAgICAgICAgcy5zcSA8LSBzXjINCiAgICAgICAgayA8LSAoc3VtKHleNCkvbikvKHYvbileMg0KICAgICAgICBzZGkgPC0gc3FydCgobiAqICgobl4yIC0gMyAqIG4gKyAzKSAqIFMxIC0gbiAqIFMyICsgMyAqIHMuc3EpIC0gayAqIChuICogKG4gLSAxKSAqIFMxIC0gMiAqIG4gKg0KICAgICAgICAgICAgUzIgKyA2ICogcy5zcSkpLygobiAtIDEpICogKG4gLSAyKSAqIChuIC0gMykgKiBzLnNxKSAtIDEvKChuIC0gMSleMikpDQogICAgICAgIGFsdGVybmF0aXZlIDwtIG1hdGNoLmFyZyhhbHRlcm5hdGl2ZSwgYygidHdvLnNpZGVkIiwgImxlc3MiLCAiZ3JlYXRlciIpKQ0KICAgICAgICBwdiA8LSBwbm9ybShvYnMsIG1lYW4gPSBlaSwgc2QgPSBzZGkpDQogICAgICAgIGlmIChhbHRlcm5hdGl2ZSA9PSAidHdvLnNpZGVkIikNCiAgICAgICAgICAgIHB2IDwtIGlmIChvYnMgPD0gZWkpDQogICAgICAgICAgICAgICAgMiAqIHB2IGVsc2UgMiAqICgxIC0gcHYpDQogICAgICAgIGlmIChhbHRlcm5hdGl2ZSA9PSAiZ3JlYXRlciIpDQogICAgICAgICAgICBwdiA8LSAxIC0gcHYNCiAgICAgICAgbGlzdChvYnNlcnZlZCA9IG9icywgZXhwZWN0ZWQgPSBlaSwgc2QgPSBzZGksIHAudmFsdWUgPSBwdikNCiAgICB9DQoNCg0KfQ0KZk1vcmFuLkkoZHJpbmtbLCAxXSwgc2NhbGVkID0gRkFMU0UsIHdlaWdodCA9IHdlaWdodHMxLCBuYS5ybSA9IFRSVUUsIHJvd3N0YW5kYXJkaXplID0gRkFMU0UpDQpgYGANCg0KTWVhbmluZyBvZiByb3dzdGFuZGFyZGl6YXRpb24NCiAtICByb3dzdGFuZGFyZGl6ZTogV2UgYXNzdW1lIHRoYXQgZWFjaCBub2RlIGkgaXMgaW5mbHVlbmNlZCBlcXVhbGx5IGJ5IGl0cyBuZWlnaGJvdXJob29kIHJlZ2FyZGxlc3Mgb24gaG93IGxhcmdlIGl0LiBZb3UgY291bGQgY29tcGFyZSB0aGlzIHRvIHRoZSBhdmVyYWdlIGFsdGVyIGVmZmVjdCBpbiBSU2llbmEpDQogLSAgbm90IHJvd3N0YW5kYXJkaXplOiBXZSBhc3N1bWUgdGhhdCBlYWNoIGFsdGVyIGogaGFzIHRoZSBzYW1lIGluZmx1ZW5jZSBvbiBpIChpZiBhdCB0aGUgc2FtZSBkaXN0YW5jZSkuIFlvdSBjb3VsZCBjb21wYXJlIHRoaXMgdG8gdGhlIHRvdGFsIGFsdGVyIGVmZmVjdCBpbiBSU2llbmEuDQogDQpUbyBub3Qgc3RhbmRhcmRpemUgaXMgZGVmYXVsdCBpbiBzbmE6Om5hY2YsIHRvIHN0YW5kYXJkaXplIGlzIGRlZmF1bHQgaW4gYXBhOjpNb3Jhbi5JLiBKb2NoZW0gVG9sc21hIHRodXMgbWFkZSBhIHNtYWxsIGFkYXB0aW9uIHRvIGFwYTo6TW9yYW4uSSBhbmQgbm93IGluIHRoZSBmdW5jdGlvbiBmTW9yYW4uSSB5b3UgY2FuIGNob29zZSBpZiB5b3Ugd2FudCB0byByb3dzdGFuZGFyZGl6ZSBvciBub3QuDQoNCldoYXQgSSByZWFsbHkgd291bGQgbGlrZSB0byBzZWUgaXMgYSBjb3JyZWxhdGlvbiBiZXR3ZWVuIGFjdG9yIGkgYW5kIGFsbCB0aGUgYWx0ZXJzIHRvIHdob20gaXQgaXMgY29ubmVjdGVkIChkaXJlY3Qgb3IgaW5kaXJlY3RseSkgYW5kIHdoZXJlIGFsdGVycyBhdCBhIGxhcmdlciBkaXN0YW5jZXMgKGxvbmdlciBzaG9ydGVzdCBwYXRoIGxlbmd0aHMpIGFyZSB3ZWlnaHRlZCBsZXNzLg0KDQpzdGVwIDE6IGZvciBlYWNoIGFjdGVyIGkgZGV0ZXJtaW5lIHRoZSBkaXN0YW5jZXMgKHNob3J0ZXN0IHBhdGggbGVuZ3RocykgdG8gYWxsIG90aGVyIG5vZGVzIGluIHRoZSBuZXR3b3JrLg0KYGBge3IsIGV2YWw9RkFMU0V9DQojIHN0ZXAgMTogY2FsY3VsYXRlIGRpc3RhbmNlcw0KZ2VvZGlzdGFuY2VzIDwtIGdlb2Rpc3QobmV0MSwgY291bnQucGF0aHMgPSBUUlVFKQ0KZ2VvZGlzdGFuY2VzIDwtIGdlb2Rpc3RhbmNlcyRnZGlzdA0KIyBzZXQgdGhlIGRpc3RhbmNlIHRvIHlvdXJzZWxmIGFzIEluZg0KZGlhZyhnZW9kaXN0YW5jZXMpIDwtIEluZg0KYGBgDQoNCnN0ZXAgMjogYmFzZWQgb24gdGhlc2UgZGlzdGFuY2VzIGRlY2lkZSBvbiBob3cgd2Ugd2FudCB0byB3ZWlnaC4gVGhhdCBpcywgZGV0ZXJtaW5lIGEgZGlzdGFuY2UgZGVjYXkgZnVuY3Rpb24uDQpgYGB7ciwgZXZhbD1GQUxTRX0NCiMgc3RlcCAyOiBkZWZpbmUgYSBkaXN0YW5jZSBkZWNheSBmdW5jdGlvbi4gVGhpcyBvbmUgaXMgcHJldHR5IHN0YW5kYXJkIGluIHRoZSBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBsaXRlcmF0dXJlIGJ1dCBhY3R1YWxseSBwcmV0dHkgYXJiaXRyYXJ5Lg0Kd2VpZ2h0czIgPC0gZXhwKC1nZW9kaXN0YW5jZXMpDQpgYGANCg0Kc3RlcCAzOiBkZWNpZGUgd2hldGhlciBvciBub3Qgd2Ugd2FudCB0byByb3ctc3RhbmRhcmRpemUuDQpgYGB7ciwgZXZhbD1GQUxTRX0NCiMgc3RlcCAzOiBJIGRvbnQgd2FudCB0byByb3dzdGFuZGFyZGl6ZS4NCmZNb3Jhbi5JKGRyaW5rWywgMV0sIHNjYWxlZCA9IEZBTFNFLCB3ZWlnaHQgPSB3ZWlnaHRzMiwgbmEucm0gPSBUUlVFLCByb3dzdGFuZGFyZGl6ZSA9IEZBTFNFKQ0KYGBgDQoNCkNvbmNsdXNpb246IFllcyBwdXBpbHMgY2xvc2VyIChoYXZlIGEgc2hvcnRlciBzaG9ydGVzdCBwYXRoIGxlbmd0aCkgdG8gb25lIGFub3RoZXIgYXJlIG1vcmUgYWxpa2UhIFlvdSBhbHNvIG9ic2VydmUgdGhhdCB0aGUgY29ycmVsYXRpb24gaXMgbG93ZXIgdGhhbiB3ZSBjYWxjdWxhdGVkIHByZXZpb3VzbHkuIEFwcGFyZW50bHksIHdlIGFyZSBhbGlrZSB0byBhbHRlcnMgdmVyeSBjbG9zZSBieSAocGF0aCBsZW5ndGggb25lKSBhbmQgbGVzcyBzbyAob3IgZXZlbiBkaXNzaW1pbGFyKSB0byBhbHRlcnMgZnVydGhlciBvZmYuDQoNCiMjIyA4LjIgLSBSYW5kb20gZ3JhcGhzDQoNCk5vdyB0aGF0IHdlIGtub3cgaG93IHRvIGNvdW50IGR5YWQgYW5kIHRyaWFkIGNvbmZpZ3VyYXRpb25zLCB0byBjYWxjdWxhdGUgbmV0d29yayBwcm9wZXJ0aWVzIGFuZCB0byBkZXRlcm1pbmUgdGhlIGV4dGVudCBvZiBzZWdyZWdhdGlvbiB3aXRoaW4gbmV0d29ya3MsIHRoZSBmb2xsb3ctdXAgcXVlc3Rpb24gaXM6IElzIHRoaXMgYSBsb3Q/IE9yIGV2ZW46IElzIHRoaXMgc2lnbmlmaWNhbnQ/IExldCB0cnkgdG8gdGFja2xlIHRoZSBsYXR0ZXIgcXVlc3Rpb24uIFdoYXQgZG8gd2UgbWVhbiB3aXRoIHNpZ25pZmljYW50PyBQcm9iYWJseSBzb21ldGhpbmcgbGlrZTogVGhlIGNoYW5jZSwgcCwgdG8gb2JzZXJ2ZSBvdXIgdmFsdWUgZm9yIG5ldHdvcmsgY2hhcmFjdGVyaXN0aWMgKG9yIHN0YXRpc3RpYyksIHMobmV0KSwgaXMgc21hbGxlciB0aGFuIHNvbWUgYXJiaXRyYXJ5IHZhbHVlLCDOsSwgd291bGQgd2UgaGF2ZSByYW5kb21seSBwaWNrZWQgYSBuZXR3b3JrIGZyb20gdGhlIGdlbmVyYWwgcG9wdWxhdGlvbiBvZiBuZXR3b3JrcywgWCwgdG8gd2hpY2ggb3VyIG9ic2VydmVkIG5ldHdvcmssIHhvLCBiZWxvbmdzLg0KDQpUaGlzIGxlYXZlcyB1cyB3aXRoIGp1c3QgdHdvIHNtYWxsZXIgcHJvYmxlbXMuIEZpcnN0LCB3aGF0IGlzIHRoaXMgcG9wdWxhdGlvbiBvZiBuZXR3b3JrcyB0byB3aGljaCBvdXIgb2JzZXJ2ZWQgbmV0d29yayBiZWxvbmdzLiBTZWNvbmQsIHdoYXQgaXMgdGhlIGRpc3RyaWJ1dGlvbiBvZiB2YWx1ZXMgZm9yIG5ldHdvcmsgY2hhcmFjdGVyaXN0aWMgcyhuZXQpIGluIHRoaXMgcG9wdWxhdGlvbj8NCg0KSW4gYSBzbWFsbCB3b3JsZCBuZXR3b3JrLCBkZXNwaXRlIGhhdmluZyBhIGxvdyBkZW5zaXR5IGFuZCBiZWluZyByZWxhdGl2ZWx5IGNsdXN0ZXJlZCwgdGhlIHJlbGF0aXZlIGF2ZXJhZ2UgcGF0aCBsZW5ndGggaXMgc21hbGwuIFdoYXQgZG8gd2UgbWVhbiB3aXRoIHJlbGF0aXZlPyBXZWxsLCBpbiBTTkEgaXQgbWVhbnMgdGhhdCBpZiB3ZSB3b3VsZCBtYWtlIGEgcmFuZG9tIGdyYXBoLCB0aGUgY2hhbmNlIGlzIHZlcnkgbG93IChsb3dlciB0aGFuIHNheSA1JSkgdGhhdCB0aGlzIGdyYXBoIHdvdWxkIGhhdmUgYSBoaWdoZXIgZGVncmVlIG9mIGNsdXN0ZXJpbmcgYW5kIGEgc2hvcnRlciBhdmVyYWdlIHBhdGggbGVuZ3RoLg0KDQpJbiBpZ3JhcGggeW91IGNhbiBnZW5lcmF0ZSByYW5kb20gZ3JhcGhzIHdpdGggdGhlICdlcmRvcy5yZW55aS5nYW1lJyBmdW5jdGlvbi4gTGV0IHVzIG1ha2UgMTAwMCByYW5kb20gZ3JhcGhzIHdpdGggc2l6ZSAxMDUgKGp1c3QgYXMgaW4gU21hbGx3b3JsZCkgYW5kIHdpdGggYSBkZW5zaXR5IG9mIDAuMTQgKGp1c3QgYXMgaW4gU21hbGx3b3JsZCkuIEFuZCBsZXQgdXMgbWFrZSBhIGhpc3RvZ3JhbSBvZiBhbGwgb2JzZXJ2ZWQgYXZlcmFnZSBkZWdyZWUgb2YgY2x1c3RlcmluZyBhbmQgcGF0aCBsZW5ndGhzLg0KDQpgYGB7ciwgZXZhbD1GQUxTRX0NCnJlcXVpcmUoaWdyYXBoKQ0KZGVucyA8LSByb3VuZChncmFwaC5kZW5zaXR5KHNtYWxsd29ybGQpLCAyKSAgI3NhdmUgZGVuc2l0eSBvZiBzbWFsbHdvcmxkDQp0cmlhbCA8LSAxMDAwICAjc2V0IG51bWJlciBvZiB0cmlhbHMvc2ltcw0KdHJpYWxjbHVzIDwtIHRyaWFsbGVuIDwtIHJlcChOQSwgdHJpYWwpICAjZGVmaW5lIG9iamVjdHMgaW4gd2hpY2ggeW91IGFyZSBzYXZpbmcgcmVzdWx0cw0KDQoNCmZvciAoaSBpbiAxOnRyaWFsKSB7DQogICAgcmFuZG9tX2dyYXBoIDwtIGVyZG9zLnJlbnlpLmdhbWUobiA9IDEwNSwgcC5vci5tID0gZGVucywgZGlyZWN0ZWQgPSBGQUxTRSkgICNtYWtlIHRoZSByYW5kb20gZ3JhcGgNCiAgICB0cmlhbGxlbltpXSA8LSBhdmVyYWdlLnBhdGgubGVuZ3RoKHJhbmRvbV9ncmFwaCwgdW5jb25uZWN0ZWQgPSBUUlVFKSAgI2NhbGN1bGF0ZSBhdmVyYWdlIHBhdGggbGVuZ3RoDQogICAgdHJpYWxjbHVzW2ldIDwtIHRyYW5zaXRpdml0eShyYW5kb21fZ3JhcGgsIGlzb2xhdGVzID0gYygiTmFOIikpICAjY2FsY3VsYXRlIGNsdXN0ZXJpbmcNCn0NCg0KDQpwYXIobWZyb3cgPSBjKDEsIDIpKQ0Kew0KICAgIGhpc3QodHJpYWxjbHVzLCB4bGltID0gYygwLjEsIDAuMzYpLCBtYWluID0gImF2ZXJhZ2UgY2x1c3RlcmluZyBjb2VmZmljaWVudCIsIHhsYWIgPSAiIiwgKQ0KICAgIGFibGluZSh2ID0gdHJhbnNpdGl2aXR5KHNtYWxsd29ybGQsIGlzb2xhdGVzID0gYygiTmFOIikpLCBjb2wgPSAicmVkIiwgbHdkID0gMykNCn0NCg0Kew0KICAgIGhpc3QodHJpYWxsZW4sIHhsaW0gPSBjKDEuOSwgMi4yKSwgbWFpbiA9ICJhdmVyYWdlIHBhdGggbGVuZ3RoIiwgeGxhYiA9ICIiKQ0KICAgIGFibGluZSh2ID0gYXZlcmFnZS5wYXRoLmxlbmd0aChzbWFsbHdvcmxkLCB1bmNvbm5lY3RlZCA9IFRSVUUpLCBjb2wgPSAicmVkIiwgbHdkID0gMykNCn0NCmBgYA0KDQoNCiMjIENoYXB0ZXIgOSAobm93IDcpIC0gTWV0aG9kcw0KDQpUaGVyZSBhcmUgbWFueSBtZXRob2RzIGZvciBhbmFseXppbmcgdGhlIGZvdXIgdGhlb3JldGljYWwgZGltZW5zaW9ucyBvZiBzb2NpYWwgbmV0d29ya3MgKGkuZS4sIHNpemUsIGNvbXBvc2l0aW9uLCBzdHJ1Y3R1cmUsIGV2b2x1dGlvbikuDQoNCklmIHdlIGZvY3VzIG9uIHRoZSBleHBsYW5hdGlvbiBvZiB0aGUgbWljcm8tbWVjaGFuaXNtcyB0aGF0IGJyaW5nIGFib3V0IHRoZSBzdHJ1Y3R1cmUgb2YgYSBzb2NpYWwgbmV0d29yaywgSSB3b3VsZCBzYXkgdGhlcmUgYXJlIHR3byBtYWluIGZsYXZvcnMgd2l0aGluIHRoZSBzb2NpYWwgc2NpZW5jZXM6DQogLSBFeHBvbmVudGlhbC1mYW1pbHkgUmFuZG9tIEdyYXBoIE1vZGVsczogZXN0aW1hdGVkIGZvciBleGFtcGxlIHdpdGggZXJnbQ0KIC0gU3RvY2hhc3RpYyBBY3RvciBPcmllbnRhdGVkIE1vZGVsczogZXN0aW1hdGVkIGZvciBleGFtcGxlIHdpdGggUlNpZW5hDQogDQpJZGVhbGx5LCB5b3Ugc2hvdWxkIHRyeSB0byB0ZXN0IHlvdXIgaHlwb3RoZXNlcyB3aXRoIGJvdGggbWV0aG9kcy4gQW5kIGlmIHJlc3VsdHMgZGlmZmVyIGFjcm9zcyBtb2RlbHMsIHRyeSB0byB1bmRlcnN0YW5kIHdoeSB0aGV5IGRvLg0KDQpXaHkgdGhlIGZvY3VzIGlzIG9uIFJTaWVuYToNCi0gIFdlIGNhbiB1c2UgdGhlIG1pY3JvLW1lY2hhbnNpc20gbm90IG9ubHkgdG8gZXhwbGFpbiB0aGUgZXZvbHVhdGlvbiBvZiBuZXR3b3JrIHN0cnVjdHVyZSBidXQgYWxzbyBvZiBuZXR3b3JrIGNvbXBvc2l0aW9uLiBQaHJhc2VkIG90aGVyd2lzZSwgV2l0aCB0aGlzIG1ldGhvZCAoYW5kIHRoZSByaWdodCB0eXBlIG9mIGRhdGEpIGl0IGlzIHBvc3NpYmxlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gc2VsZWN0aW9uIGFuZCBpbmZsdWVuY2UgcHJvY2Vzc2VzDQoNCiMjIyBHZXR0aW5nIHN0YXJ0ZWQgd2l0aCBzZXR0aW5nIHVwIFINCg0KYGBge3IsIGV2YWw9RkFMU0V9DQpybShsaXN0ID0gbHMoKSkNCg0KZnBhY2thZ2UuY2hlY2sgPC0gZnVuY3Rpb24ocGFja2FnZXMpIHsNCiAgICBsYXBwbHkocGFja2FnZXMsIEZVTiA9IGZ1bmN0aW9uKHgpIHsNCiAgICAgICAgaWYgKCFyZXF1aXJlKHgsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkpIHsNCiAgICAgICAgICAgIGluc3RhbGwucGFja2FnZXMoeCwgZGVwZW5kZW5jaWVzID0gVFJVRSkNCiAgICAgICAgICAgIGxpYnJhcnkoeCwgY2hhcmFjdGVyLm9ubHkgPSBUUlVFKQ0KICAgICAgICB9DQogICAgfSkNCn0NCg0KZnNhdmUgPC0gZnVuY3Rpb24oeCwgZmlsZSA9IE5VTEwsIGxvY2F0aW9uID0gIi4vZGF0YS9wcm9jZXNzZWQvIikgew0KICAgIGlmZWxzZSghZGlyLmV4aXN0cygiZGF0YSIpLCBkaXIuY3JlYXRlKCJkYXRhIiksIEZBTFNFKQ0KICAgIGlmZWxzZSghZGlyLmV4aXN0cygiZGF0YS9wcm9jZXNzZWQiKSwgZGlyLmNyZWF0ZSgiZGF0YS9wcm9jZXNzZWQiKSwgRkFMU0UpDQogICAgaWYgKGlzLm51bGwoZmlsZSkpDQogICAgICAgIGZpbGUgPSBkZXBhcnNlKHN1YnN0aXR1dGUoeCkpDQogICAgZGF0ZW5hbWUgPC0gc3Vic3RyKGdzdWIoIls6LV0iLCAiIiwgU3lzLnRpbWUoKSksIDEsIDgpDQogICAgdG90YWxuYW1lIDwtIHBhc3RlKGxvY2F0aW9uLCBkYXRlbmFtZSwgZmlsZSwgIi5yZGEiLCBzZXAgPSAiIikNCiAgICBzYXZlKHgsIGZpbGUgPSB0b3RhbG5hbWUpICAjbmVlZCB0byBmaXggaWYgZmlsZSBpcyByZWxvYWRlZCBhcyBpbnB1dCBuYW1lLCBub3QgYXMgeC4gDQp9DQoNCmZsb2FkIDwtIGZ1bmN0aW9uKGZpbGVuYW1lKSB7DQogICAgbG9hZChmaWxlbmFtZSkNCiAgICBnZXQobHMoKVtscygpICE9ICJmaWxlbmFtZSJdKQ0KfQ0KDQpmc2hvd2RmIDwtIGZ1bmN0aW9uKHgsIC4uLikgew0KICAgIGtuaXRyOjprYWJsZSh4LCBkaWdpdHMgPSAyLCAiaHRtbCIsIC4uLikgJT4lDQogICAgICAgIGthYmxlRXh0cmE6OmthYmxlX3N0eWxpbmcoYm9vdHN0cmFwX29wdGlvbnMgPSBjKCJzdHJpcGVkIiwgImhvdmVyIikpICU+JQ0KICAgICAgICBrYWJsZUV4dHJhOjpzY3JvbGxfYm94KHdpZHRoID0gIjEwMCUiLCBoZWlnaHQgPSAiMzAwcHgiKQ0KfQ0KDQpwYWNrYWdlcyA9IGMoIlJTaWVuYSIsICJkZXZ0b29scyIsICJpZ3JhcGgiKQ0KZnBhY2thZ2UuY2hlY2socGFja2FnZXMpDQojIGRldnRvb2xzOjppbnN0YWxsX2dpdGh1YignSm9jaGVtVG9sc21hL1JzaWVuYVR3b1N0ZXAnLCBidWlsZF92aWduZXR0ZXM9VFJVRSkNCnBhY2thZ2VzID0gYygiUnNpZW5hVHdvU3RlcCIpDQpmcGFja2FnZS5jaGVjayhwYWNrYWdlcykNCmBgYA0KDQojIyMgNy40IC0gUlNpZW5hIGFzIEFCTQ0KDQpSU2llbmEgbW9kZWxzIHRoZSBldm9sdXRpb24gb2YgbmV0d29yayBzdHJ1Y3R1cmVzIGFuZC9vciB0aGUgYmVoYXZpb3Igb2YgdGhlIHNvY2lhbCBhZ2VudHMuIEl0IHRha2VzIHRoZSBjdXJyZW50IHNpdHVhdGlvbiBUMCBhcyBzdGFydGluZyBwb2ludC4gSXQgZXN0aW1hdGVzIHRoZSDigJhydWxlc+KAmSBmb3IgdGhlIGFnZW50cyBob3cgdG8gY2hhbmdlIHRoZWlyIHRpZXMgYW5kL29yIGJlaGF2aW9yLiBJZiB0aGUgbW9kZWwgaXMgc3BlY2lmaWVkIGNvcnJlY3RseSwgdGhlc2UgcnVsZXMgKG9yIG1pY3JvIG1lY2hhbmlzbXMpIGhhdmUgbGVkIHRoZSBzaXR1YXRpb24gYXQgVDAgdG8gZXZvbHZlIGludG8gdGhlIHNpdHVhdGlvbiBvYnNlcnZlZCBhdCBUMS4NCg0KV2hhdCBkb2VzIFJTaWVuYSBkbyBhbmQgbm90IGRvPw0KLSBObyByZS1hY3Rpdml0eTogVGhlIGFjdCBvZiByZS1hZmZpcm1pbmcsIG1ha2luZyBvciBicmVha2luZyBhbiBvdXRnb2luZyB0aWUgZG9lcyBub3QgdHJpZ2dlciBhIHJlc3BvbnNlIGJ5IHRoZSBpbnZvbHZlZCBhbHRlcg0KLSBObyBzaW11bHRhbmVpdHk6IENoYW5nZXMgb2NjdXIgb25lIGJ5IG9uZQ0KLSBIZW5jZSBhbHNvIG5vIGNvb3BlcmF0aW9uLCBjb29yZGluYXRpb24gb3IgbmVnb3RpYXRpb24NCi0gTm8gbWF4aW1pemF0aW9uIG9mIHRvdGFsIHV0aWxpdHk6DQogKyBObyBhbHRydWlzdGljIGJlaGF2aW9yOiBJbmRpdmlkdWFsIHV0aWxpdHkgaXMgbWF4aW1pemVkLCBub3QgdG90YWwgdXRpbGl0eQ0KLSBObyBzdHJhdGVnaWMgYmVoYXZpb3INCiAgKyBWZXJ5IGZpbml0ZSB0aW1lIGhvcml6b24uIEFnZW50IGRvZXMgbm90IHByZWRpY3QgaG93IGhpcy9oZXIgZnV0dXJlIGxvY2FsIG5ldHdvcmsgbmVpZ2hib3Job29kIG1heSBjaGFuZ2UgYWZ0ZXI6DQogICAgLSBNYWtpbmcgYW5vdGhlciBtaW5pc3RlcCBoaW0vaGVyc2VsZg0KICAgIC0gQSBtaW5pc3RlcCBvZiBvdGhlciBhZ2VudHMNCiAgKyBIZW5jZSBhbHNvIG5vIGludmVzdG1lbnRzDQoNClRoaXMgZG9lcyBub3QgbWVhbiB0aGF0IFJTaWVuYSBjYW5ub3QgZXN0aW1hdGUgKG9yIGJldHRlcjog4oCYZml04oCZKSB0aGUgZXZvbHV0aW9uIG9mIG5ldHdvcmtzL2JlaGF2aW9yIHRoYXQgYXJlIHRoZSBjb25zZXF1ZW5jZXMgb2YgdGhlc2UgbW9yZSBjb21wbGV4IOKAmHJ1bGVz4oCZIG9yIG1pY3JvIHRoZW9yaWVzIGJ1dCBpdCBhc3N1bWVzIGFjdG9ycyBvbmx5IG1ha2UgbWluaXN0ZXBzLg0KDQojIyMgNy41IC0gU2ltdWxhdGlvbiBsb2dpYw0KDQotIFNhbXBsZSBlZ28NCi0gQ29uc3RydWN0IHBvc3NpYmxlIGFsdGVybmF0aXZlIGZ1dHVyZSBuZXR3b3JrcyBiYXNlZCBvbiBhbGwgcG9zc2libGUgbWluaXN0ZXBzIG9mIGVnbw0KLSBDYWxjdWxhdGUgaG93IHNhbXBsZWQgZWdvIGV2YWx1YXRlcyB0aGVzZSBwb3NzaWJsZSBuZXR3b3Jrcw0KLSBMZXQgdGhlIGVnbyBwaWNrIGEgbmV0d29yaywgdGhhdCBpcywgbGV0IGFnZW50IGRlY2lkZSBvbiBhIHRpZS1jaGFuZ2UNCi0gR09UTyAxIChTVE9QUElORyBSVUxFOiB1bnRpbCB5b3UgdGhpbmsgd2UgaGF2ZSBtYWRlIGVub3VnaCBtaW5pc3RlcHMpDQoNCiMjIyMgNy41LjEgLSBTYW1wbGluZyBhbiBlZ28NCg0KYGBge3IsIGV2YWw9RkFMU0V9DQpuZXQxDQoNCiMgUGxvdHRpbmcgbmV0MQ0KDQpuZXQxZyA8LSBncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgobmV0MSwgbW9kZSA9ICJkaXJlY3RlZCIpDQpjb29yZHMgPC0gbGF5b3V0XyhuZXQxZywgbmljZWx5KCkpICAjbGV0IHVzIGtlZXAgdGhlIGxheW91dA0KcGFyKG1hciA9IGMoMC4xLCAwLjEsIDAuMSwgMC4xKSkNCnsNCiAgICBwbG90LmlncmFwaChuZXQxZywgbGF5b3V0ID0gY29vcmRzKQ0KICAgIGdyYXBoaWNzOjpib3goKQ0KfQ0KDQpgYGANCg0KU28gb25seSBvbmUgYWN0b3IgaXMgYWxsb3dlZCB0byBtYWtlIG9uZSBtaW5pc3RlcC4gQnV0IHdobz8gVGhpcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSByYXRlIGZ1bmN0aW9uIGFuZCBpdCBtYXkgZGVwZW5kIG9uIGVnby1jaGFyYWN0ZXJpc3RpY3Mgb2Ygb3VyIHNvY2lhbCBhZ2VudHMgKGUuZy4gbWFsZS9mZW1hbGUpIGFuZC9vciBvbiBzdHJ1Y3R1cmFsLWNoYXJhY3RlcmlzdGljcyBvZiBvdXIgc29jaWFsIGFnZW50cyAoZS5nLiBpbmRlZ3JlZSwgb3V0ZGVncmVlKS4gQW5kIGFsbCB0aGlzIGNhbiBiZSBlc3RpbWF0ZWQgd2l0aGluIFJTaWVuYS4gTW9yZSBvZnRlbiB0aGFuIG5vdGUsIHdlIHNpbXBseSBhc3N1bWUgdGhhdCBhbGwgYWN0b3JzIGhhdmUgYW4gZXF1YWwgY2hhbmNlIG9mIGJlaW5nIHNlbGVjdGVkIHRvIG1ha2UgYSBtaW5pc3RlcC4NCg0KRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIHJhdGUgZnVuY3Rpb24gc2VlIChyZWY6I3JwKS4NCg0KT2theSwgd2UgY2FuIHRodXMgcmFuZG9tbHkgc2VsZWN0L3NhbXBsZSBhbiBhZ2VudC4NCg0KYGBge3IsIGV2YWw9RkFMU0V9DQpzZXQuc2VlZCgyNDU1MzI1MykNCmVnbyA8LSB0c19zZWxlY3QobmV0ID0gbmV0MSwgc3RlcHMgPSAxKSAgI2luIHJzaWVuYXR3b3N0ZXAgdHdvIGFjdG9ycyBtYXkgbWFrZSBhIGNoYW5nZSB0b2dldGhlciBidXQgaGVyZSBub3QNCmVnbw0KYGBgDQoNCiMjIyMgNy41LjIgLSBQb3NzaWJsZSBuZXR3b3JrcyBhZnRlciBtaW5pc3RlcA0KDQpMZXQgdXMgc3VwcG9zZSB3ZSB3YW50IHRvIGtub3cgd2hhdCB0aGUgcG9zc2libGUgbmV0d29ya3MgYXJlIGFmdGVyIGFsbCBwb3NzaWJsZSBtaW5pc3RlcHMgb2YgZWdvIHdobyBpcyBwYXJ0IG9mIG5ldDEuIFRoYXQgaXMsIGxldCB1cyBhc3N1bWUgdGhhdCBpdCBpcyBlZ2/igJlzIHR1cm4gKGVnbyM6IDQpIHRvIGRlY2lkZSBvbiB0aWUtY2hhbmdlLiBXaGF0IGFyZSB0aGUgcG9zc2libGUgbmV0d29ya3M/DQoNClRoZSBmdW5jdGlvbiB0c19hbHRlcm5hdGl2ZXNfbWluaXN0ZXAoKSByZXR1cm5zIGEgbGlzdCBvZiBhbGwgcG9zc2libGUgbmV0d29ya3MgYWZ0ZXIgYWxsIHBvc3NpYmxlIHRpZS1jaGFuZ2VzIGF2YWlsYWJsZSB0byBhbiBlZ28gZ2l2ZW4gbmV0d29yayBkYSBuZXR3b3JrLg0KDQpgYGB7ciwgZXZhbD1GQUxTRX0NCm9wdGlvbnMgPC0gdHNfYWx0ZXJuYXRpdmVzX21pbmlzdGVwKG5ldCA9IG5ldDEsIGVnbyA9IGVnbykNCm9wdGlvbnMNCnBsb3RzIDwtIGxhcHBseShvcHRpb25zLCBncmFwaF9mcm9tX2FkamFjZW5jeV9tYXRyaXgsIG1vZGUgPSAiZGlyZWN0ZWQiKQ0KcGFyKG1hciA9IGMoMCwgMCwgMCwgMCkgKyAwLjEpDQpwYXIobWZyb3cgPSBjKDIsIDIpKQ0KDQpmcGxvdCA8LSBmdW5jdGlvbih4KSB7DQogICAgcGxvdC5pZ3JhcGgoeCwgbGF5b3V0ID0gY29vcmRzLCBtYXJnaW4gPSAwKQ0KICAgIGdyYXBoaWNzOjpib3goKQ0KfQ0KDQpsYXBwbHkocGxvdHMsIGZwbG90KQ0KDQpgYGANCg0KIyMjIyA3LjUuMyAtIE5ldHdvcmsgc3RhdGlzdGljcw0KDQpUaGUgb3B0aW9uIGFuIGVnbyB3aWxsIGNob29zZSBkZXBlbmRzIG9uIHdoaWNoIG5ldHdvcmsgY2hhcmFjdGVyaXN0aWNzIChvciBzdGF0aXN0aWNzKSBlZ28gZmluZHMgcmVsZXZhbnQuIExldCB1cyBzdXBwb3NlIHRoYXQgZWdvIGJhc2VzIGl0cyBkZWNpc2lvbiBzb2xlbHkgb24gdGhlIG51bWJlciBvZiB0aWVzIGl0IHNlbmRzIHRvIG90aGVycyBhbmQgdGhlIG51bWJlciBvZiByZWNpcHJvY2F0ZWQgdGllcyBpdCBoYXMgd2l0aCBvdGhlcnMuDQoNCkZpcnN0OiBjb3VudCB0aGUgb3V0ZGVncmVlDQpgYGB7ciwgZXZhbD1GQUxTRX0NCnRzX2RlZ3JlZShuZXQgPSBvcHRpb25zW1sxXV0sIGVnbyA9IGVnbykNCg0KIyBvciBmb3IgYWxsIG9wdGlvbnMNCg0KbGFwcGx5KG9wdGlvbnMsIHRzX2RlZ3JlZSwgZWdvID0gZWdvKQ0KYGBgDQoNClRoZW4gY291bnQgdGhlIG51bWJlciBvZiByZWNpcHJvY2F0ZWQgdGllcw0KYGBge3IsIGV2YWw9RkFMU0V9DQpsYXBwbHkob3B0aW9ucywgdHNfcmVjaXAsIGVnbyA9IGVnbykNCmBgYA0KDQpOZXR3b3JrIHN0YXRpc3RpY3MgaW4gdGhlIHBhY2thZ2UgJ1JzaWVuYVR3b1N0ZXAnOiANCg0KLSBkZWdyZWU6IHRzX2RlZ3JlZSgpDQotIHJlY2lwcm9jaXR5OiB0c19yZWNpcCgpDQotIG91dGRlZ3JlZSBhY3Rpdml0eTogdHNfb3V0QWN0KCkNCi0gaW5kZWdyZWUgYWN0aXZpdHk6IHRzX2luQWN0KCkNCi0gb3V0ZGVncmVlIHBvcHVsYXJpdHk6IHRzX291dFBvcCgpDQotIGluZGVncmVlIHBvcHVsYXJpdHk6IHRzX2luUG9wKCkNCi0gdHJhbnNpdGl2aXR5OiB0c190cmFuc1RyaXAoKQ0KLSBtZWRpYXRlZCB0cmFuc2l0aXZpdHk6IHRzX3RyYW5zTWVkVHJpcCgpDQotIHRyYW5zaXRpdmUgcmVjaXByb2NhdGVkIHRyaXBsZXRzOiB0c190cmFuc1JlY1RyaXAoKQ0KLSBudW1iZXIgb2YgdGhyZWUtY3ljbGVzOiB0c19jeWNsZTMoKQ0KDQojIyMjIDcuNS40IC0gRXZhbHVhdGlvbiBmdW5jdGlvbg0KDQpCdXQgd2hhdCBldmFsdWF0aW9uIHZhbHVlIGRvZXMgZWdvIGF0dGFjaCB0byB0aGVzZSBuZXR3b3JrIHN0YXRpc3RpY3MgYW5kIGNvbnNlcXVlbnRseSB0byB0aGUgbmV0d29yayAoaW4gaXRzIHZpY2luaXR5KSBhcyBhIHdob2xlPyBXZWxsIHRoZXNlIGFyZSB0aGUgcGFyYW1ldGVycywgzrJpLCB5b3Ugd2lsbCBub3JtYWxseSBlc3RpbWF0ZSB3aXRoIFJTaWVuYTo6c2llbmEwNygpLiBMZXQgdXMgc3VwcG9zZSB0aGUgaW1wb3J0YW5jZSBmb3I6DQoNCi0gdGhlIHN0YXRpc3RpYyDigJhkZWdyZWXigJksICDOsjEsIGlzIC0xDQotIGZvciB0aGUgc3RhdGlzdGljIOKAmHJlY2lwcm9jaXR54oCZLCAgzrIyLCBpcyAxLjUuDQoNCmBgYHtyLCBldmFsPUZBTFNFfQ0Kb3B0aW9uIDwtIDQNCnRzX2RlZ3JlZShvcHRpb25zW1tvcHRpb25dXSwgZWdvID0gZWdvKSAqIC0xICsgdHNfcmVjaXAob3B0aW9uc1tbb3B0aW9uXV0sIGVnbyA9IGVnbykgKiAxLjUNCg0KIyBPciB1c2UgYXMgdHNfZXZhbCgpDQoNCmV2YWwgPC0gdHNfZXZhbChuZXQgPSBvcHRpb25zW1tvcHRpb25dXSwgZWdvID0gZWdvLCBzdGF0aXN0aWNzID0gbGlzdCh0c19kZWdyZWUsIHRzX3JlY2lwKSwgcGFyYW1ldGVycyA9IGMoLTEsDQogICAgMS41KSkNCmV2YWwNCmBgYA0KDQpOb3csIGxldCdzIGNhbGN1bGF0ZSB0aGUgZXZhbHVhdGlvbiBvZiBhbGwgcG9zc2libGUgbmV0d29ya3M6DQoNCmBgYHtyLCBldmFsPUZBTFNFfQ0KZXZhbCA8LSBzYXBwbHkob3B0aW9ucywgRlVOID0gdHNfZXZhbCwgZWdvID0gZWdvLCBzdGF0aXN0aWNzID0gbGlzdCh0c19kZWdyZWUsIHRzX3JlY2lwKSwgcGFyYW1ldGVycyA9IGMoLTEsDQogICAgMS41KSkNCmV2YWwNCnByaW50KCJuZXR3b3JrIHdpdGggbWF4aW11bSBldmFsdWF0aW9uIHNjb3JlOiIpDQp3aGljaC5tYXgoZXZhbCkNCmBgYA0KDQojIyMjIDcuNS41IC0gQ2hvaWNlIGZ1bmN0aW9uDQoNClNvIHdoaWNoIG9wdGlvbiB3aWxsIGVnbyBjaG9vc2U/IE5hdHVyYWxseSB0aGlzIHdpbGwgYmUgYSBzdG9jaGFzdGljIHByb2Nlc3MuIEJ1dCB3ZSBzZWUgdGhhdCBvcHRpb24gNCBoYXMgdGhlIGhpZ2hlc3QgZXZhbHVhdGlvbi4gDQpGb3JjaW5nIGVnbyB0byBtYWtlIGEgZGVjaXNpb246DQoNCmBgYHtyLCBldmFsPUZBTFNFfQ0KY2hvaWNlIDwtIHNhbXBsZSgxOmxlbmd0aChldmFsKSwgc2l6ZSA9IDEsIHByb2IgPSBleHAoZXZhbCkvc3VtKGV4cChldmFsKSkpDQpwcmludCgiY2hvaWNlOiIpDQpjaG9pY2UNCiMgcHJpbnQoJ25ldHdvcms6Jykgb3B0aW9uc1tbY2hvaWNlXV0NCmBgYA0KDQpJZiB3ZSByZXBlYXQgdGhpcyBwcm9jZXNzIHdlIGhhdmUgYW4gYWdlbnQgYmFzZWQgbW9kZWwNClRoZSBwcm9jZXNzOiANCi0gc2FtcGxlIGFnZW50DQotIGNvbnN0cnVjdCBwb3NzaWJsZSBhbHRlcm5hdGl2ZSBuZXR3b3Jrcw0KLSBjYWxjdWxhdGUgaG93IHNhbXBsZWQgYWdlbnQgZXZhbHVhdGVzIHRoZSBwb3NzaWJsZSBuZXR3b3Jrcw0KLSBMZXQgdGhlIGFnZW50IHBpY2sgYSBuZXR3b3JrLCB0aGF0IGlzLCBsZXQgYWdlbnQgZGVjaWRlIG9uIGEgdGllLWNoYW5nZQ0KLSBHTyBCQUNLIFRPIDEgKFNUT1BQSU5HIFJVTEU6IHVudGlsIHlvdSB0aGluayB3ZSBoYXZlIG1hZGUgZW5vdWdoIG1pbmlzdGVwcykNCg0KIyMjIyA3LjUuNiAtIFN0b3BwaW5nIHJ1bGUNCg0KQnV0IGhvdyBtYW55IG1pbmlzdGVwcyBkbyB3ZSBhbGxvdz8gV2VsbCwgbm9ybWFsbHkgdGhpcyBpcyBlc3RpbWF0ZWQgYnkgc2llbmEwNyBieSB0aGUgcmF0ZSBwYXJhbWV0ZXIuIElmIHdlIGRvIG5vdCBtYWtlIHRoaXMgcmF0ZSBwYXJhbWV0ZXIgY29uZGl0aW9uYWwgb24gYWN0b3IgY292YXJpYXRlcyBvciBvbiBuZXR3b3JrIGNoYXJhY3RlcmlzdGljcywgdGhlIHJhdGUgcGFyYW1ldGVyIGNhbiBiZSBpbnRlcnByZXRlZCBhcyB0aGUgYXZlcmFnZSBudW1iZXIgb2YgbWluaXN0ZXBzIGVhY2ggYWN0b3IgaW4gdGhlIG5ldHdvcmsgaXMgYWxsb3dlZCB0byBtYWtlIGJlZm9yZSB0aW1lIGlzIHVwLiBMZXQgdXMgc3VwcG9zZSB0aGUgcmF0ZSBwYXJhbWV0ZXIgaXMgMiAuIFRodXMgaW4gdG90YWwgdGhlIG51bWJlciBvZiBwb3NzaWJsZSBtaW5pc3RlcHMgd2lsbCBiZSBucm93KG5ldDEpKnJhdGU6IDIwLg0KDQojIyMgNy42IC0gU2ltdWxhdGlvbiBleGFtcGxlDQoNCkxldCB1cyBub3cgc2ltdWxhdGUgaG93IHRoZSBuZXR3b3JrIGNvdWxkIGV2b2x2ZSBnaXZlbjoNCg0KLSBzdGFydGluZyBwb2ludCBpcyBuZXQxDQotIHJhdGUgaXMgc2V0IHRvIDINCi0gd2UgYXMgc2NpZW50aXN0cyB0aGluayBvbmx5IG5ldHdvcmsgc3RhdGlzdGljcyBkZWdyZWUgYW5kIHJlY2lwcm9jaXR5IGFyZSBpbXBvcnRhbnQNCi0gUlNpZW5hOjpzaWVuYTA3IGhhcyBkZXRlcm1pbmVkIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGVzZSBzdGF0aXN0aWNzIGFyZSAtMSBhbmQgMS41IHJlc3BlY3RpdmVseQ0KLSBXZSBhZGhlcmUgdG8gdGhlIG1pbmlzdGVwIGFzc3VtcHRpb24gYW5kIGhlbmNlIHNldCBwMnN0ZXAgdG8gYygxLDAsMCkNCg0KYGBge3IsIGV2YWw9RkFMU0V9DQp0c19zaW1zKG5zaW1zID0gMSwgbmV0ID0gbmV0MSwgcmF0ZSA9IDIsIHN0YXRpc3RpY3MgPSBsaXN0KHRzX2RlZ3JlZSwgdHNfcmVjaXApLCBwYXJhbWV0ZXJzID0gYygtMSwgMS41KSwNCiAgICBwMnN0ZXAgPSBjKDEsIDAsIDApLCBjaGFpbiA9IEZBTFNFKQ0KYGBgDQoNCiMjIyA3LjcgRXN0aW1hdGlvbiBsb2dpYw0KDQpFc3RpbWF0aW9uIHByb2NlZHVyZSBpbiBSU2llbmE6DQotIERlZmluZSBtb2RlbDogcmVzZWFyY2hlciBpbmNsdWRlcyBlZmZlY3RzDQotIGluaXRpYWwgcGFyYW1ldGVyIHZhbHVlcyBvZiBlZmZlY3RzIChjb21tb25seSDigJgw4oCZKQ0KLSBzaW11bGF0ZSBhbiBvdXRjb21lIG5ldHdvcmsgYmFzZWQgb24gdGhlc2UgcGFyYW1ldGVyIHZhbHVlcw0KLSBjb21wYXJlIHRoZSBuZXR3b3JrIHN0YXRpc3RpY3Mgb2YgdGhlIHNpbXVsYXRlZCBvdXRjb21lIG5ldHdvcmsgd2l0aCB0aGUgb2JzZXJ2ZWQgb3V0Y29tZSBuZXR3b3JrIChpLmUuIHRoZSB0YXJnZXQgdmFsdWVzKQ0KICArIGJhc2VkIG9uIHRoZSBpbmNsdWRlZCBlZmZlY3RzLiBUaHVzIHRoZSBzaW11bGF0ZWQgbmV0d29yayBtYXkgY29udGFpbiAxMCB0aWVzLCBidXQgdGhlIG9ic2VydmVkIG5ldHdvcmsgbWF5IGNvbnRhaW4gMjAgdGllcy4gQXBwYXJlbnRseSwgd2l0aCB0aGUgY3VycmVudCBwYXJhbWV0ZXIgdmFsdWVzIHdlIHVuZGVyZXN0aW1hdGUgdGhlIGRlbnNpdHkgb2YgdGhlIG91dGNvbWUgbmV0d29yay4NCi0gdHdlYWsvdXBkYXRlIHBhcmFtZXRlciB2YWx1ZXMgaW4gc29tZSBzbWFydCB3YXkNCi0gR09UTyAzIChCUkVBSyBSVUxFOiB1bnRpbCBwYXJhbWV0ZXIgdmFsdWVzIGNhbm5vdCBiZSBpbXByb3ZlZCBhbnltb3JlIC8gb3IgcmVhY2hlZCBnb29kIGZpdCkNCi0gc2ltdWxhdGUgYSBidW5jaCBvZiBvdXRjb21lIG5ldHdvcmtzIHdpdGggdGhlIG9idGFpbmVkIHBhcmFtZXRlciB2YWx1ZXMgYW5kIGNvbXBhcmUgdGhlIGV4cGVjdGVkIHZhbHVlcyBvZiBzdGF0aXN0aWNzIG9mIHRoZSBvdXRjb21lIG5ldHdvcmtzIHdpdGggdGhlIHRhcmdldCB2YWx1ZXMuDQogICsgd2UgY2FuIGFzc2VzcyB0aGUgZml0DQogICsgZXN0aW1hdGUgU0Ugb2YgdGhlIHBhcmFtZXRlcnMNCiAgDQojIyMgNy44IEludGVycHJldGF0aW9uIG9mIHBhcmFtZXRlcnMNCg0KIyMjIyA3LjguMSAtIFJhdGUgcGFyYW1ldGVyDQoNCmVzdGltYXRlZCByYXRlIHBhcmFtZXRlciAtLT4gdGhlIGV4cGVjdGVkIG51bWJlciBvZiBvcHBvcnR1bml0aWVzIGZvciBjaGFuZ2UgcGVyIGFjdG9yIGluIGEgdGltZSBwZXJpb2QuDQoNClN1cHBvc2Ugd2UgaGF2ZSB0aHJlZSBhY3RvcnM6IGksIGogYW5kIGsuIEFuZCBzdXBwb3NlIHRoYXQgdGhlIHJhdGUgZnVuY3Rpb24gaXMgYSBjb25zdGFudCwgdGh1cyB0aGUgcmF0ZSBmdW5jdGlvbiBkb2VzIG5vdCBkZXBlbmQgb24gdGhlIG5ldHdvcmsgc3RydWN0dXJlIG9yIGF0dHJpYnV0ZXMgb2YgdGhlIGFjdG9ycy4gVGh1cyBzdXBwb3NlIGZvciBleGFtcGxlOg0KDQrOu2kgPSA1DQrOu2ogPSAxMA0KzrtrID0gMTUNCiANClRoZSB3YWl0aW5nIHRpbWVzIG9mIGFjdG9ycyBpLCBqIGFuZCBrIGFyZSBleHBvbmVudGlhbGx5IGRpc3RyaWJ1dGVkIHdpdGggcmF0ZSBwYXJhbWV0ZXIgzrsuIFRoZSBleHBvbmVudGlhbCBkaXN0cmlidXRpb24gbG9va3MgbGlrZToNCg0KYGBge3IsIGV2YWw9RkFMU0V9DQpwYXIobWZyb3cgPSBjKDEsIDMpKQ0KDQpkaXN0XzUgPC0gcmV4cCgxMDAwMCwgcmF0ZSA9IDUpDQpoaXN0KGRpc3RfNSwgbWFpbiA9ICJyYXRlID0gbGFtYmRhX2kgPSA1IiwgZnJlcSA9IEZBTFNFLCB4bGFiID0gIndhaXRpbmcgdGltZXMiLCB4bGltID0gYygwLCAyKSwgeWxpbSA9IGMoMCwNCiAgICA5KSkNCmFibGluZSh2ID0gMS81LCBjb2wgPSAicmVkIikNCg0KZGlzdF8xMCA8LSByZXhwKDEwMDAwLCByYXRlID0gMTApDQpoaXN0KGRpc3RfMTAsIG1haW4gPSAicmF0ZT0gbGFtYmRhX2ogPSAxMCIsIGZyZXEgPSBGQUxTRSwgeGxhYiA9ICJ3YWl0aW5nIHRpbWVzIiwgeGxpbSA9IGMoMCwgMiksIHlsaW0gPSBjKDAsDQogICAgOSkpDQphYmxpbmUodiA9IDEvMTAsIGNvbCA9ICJyZWQiKQ0KDQpkaXN0XzE1IDwtIHJleHAoMTAwMDAsIHJhdGUgPSAxNSkNCmhpc3QoZGlzdF8xMCwgbWFpbiA9ICJyYXRlID0gbGFtYmRhX2sgPSAxNSIsIGZyZXEgPSBGQUxTRSwgeGxhYiA9ICJ3YWl0aW5nIHRpbWVzIiwgeGxpbSA9IGMoMCwgMiksIHlsaW0gPSBjKDAsDQogICAgOSkpDQphYmxpbmUodiA9IDEvMTUsIGNvbCA9ICJyZWQiKQ0KYGBgDQoNCkRldGVybWluaW5nIHdoaWNoIGFjdG9yIGlzIGFsbG93ZWQgdG8gZG8gYSBuZXh0IG1pbmlzdGVwOiBzYW1wbGUgYSB3YWl0aW5nIHRpbWUgZm9yIGVhY2ggYWN0b3IuIFRodXMgZWFjaCBhY3RvciBnZXRzIGEgd2FpdGluZyB0aW1lIHNhbXBsZWQgZnJvbSB0aGUgZXhwb25lbnRpYWwgZGlzdHJpYnV0aW9uIHdpdGggdGhlIHNwZWNpZmllZCByYXRlIHBhcmFtZXRlcjoNCg0KYGBge3IsIGV2YWw9RkFMU0V9DQpzZXQuc2VlZCgzNDY0MSkNCndhaXRpbmd0aW1lcyA8LSBOQQ0Kd2FpdGluZ3RpbWVzWzFdIDwtIHJleHAoMSwgcmF0ZSA9IDUpDQp3YWl0aW5ndGltZXNbMl0gPC0gcmV4cCgxLCByYXRlID0gMTApDQp3YWl0aW5ndGltZXNbM10gPC0gcmV4cCgxLCByYXRlID0gMTUpDQpwcmludChwYXN0ZSgid2FpdGluZ3RpbWVfIiwgYygiaTogIiwgImo6ICIsICJrOiAiKSwgcm91bmQod2FpdGluZ3RpbWVzLCAzKSwgc2VwID0gIiIpKQ0KYGBgDQoNClJlcGVhdCB0aGlzIHByb2Nlc3Mgb2YgZGV0ZXJtaW5pbmcgd2hvIGlzIGFsbG93ZWQgdG8gdGFrZSBhIG1pbmlzdGVwIGEgY291cGxlIG9mIHRpbWVzIGFuZCBrZWVwIHRyYWNrIG9mIHdobyB3aWxsIG1ha2UgdGhlIG1pbmlzdGVwIGFuZCB0aGUgdGltZSB0aGF0IGhhcyBwYXNzZWQ6DQoNCmBgYHtyLCBldmFsPUZBTFNFfQ0Kc2V0LnNlZWQoMjQ1NjUxKQ0Kc2FtX3dhaXRpbmd0aW1lcyA8LSBOQQ0KdGltZSA8LSAwDQpmb3IgKG1pbmlzdGVwcyBpbiAxOjUwKSB7DQogICAgd2FpdGluZ3RpbWVzIDwtIE5BDQogICAgd2FpdGluZ3RpbWVzWzFdIDwtIHJleHAoMSwgcmF0ZSA9IDUpDQogICAgd2FpdGluZ3RpbWVzWzJdIDwtIHJleHAoMSwgcmF0ZSA9IDEwKQ0KICAgIHdhaXRpbmd0aW1lc1szXSA8LSByZXhwKDEsIHJhdGUgPSAxNSkNCiAgICBhY3RvciA8LSB3aGljaCh3YWl0aW5ndGltZXMgPT0gbWluKHdhaXRpbmd0aW1lcykpDQogICAgdGltZSA8LSB0aW1lICsgd2FpdGluZ3RpbWVzW2FjdG9yXQ0KICAgIHNhbV93YWl0aW5ndGltZXNbbWluaXN0ZXBzXSA8LSB3YWl0aW5ndGltZXNbYWN0b3JdDQogICAgcHJpbnQocGFzdGUoIm1pbmlzdGVwIG5yLjogIiwgbWluaXN0ZXBzLCBzZXAgPSAiIikpDQogICAgcHJpbnQocGFzdGUoIndhaXRpbmd0aW1lXyIsIGMoImk6ICIsICJqOiAiLCAiazogIilbYWN0b3JdLCByb3VuZCh3YWl0aW5ndGltZXMsIDMpW2FjdG9yXSwgc2VwID0gIiIpKQ0KICAgIHByaW50KHBhc3RlKCJ0aW1lIHBhc3Q6ICIsIHJvdW5kKHRpbWUsIDMpLCBzZXAgPSAiIikpDQp9DQpgYGANCg0KUGxvdCB0aGUgc2FtcGxlZCB3YWl0aW5nIHRpbWVzOg0KDQpgYGB7ciwgZXZhbD1GQUxTRX0NCnNldC5zZWVkKDI0NTY1MSkNCnNhbV93YWl0aW5ndGltZXMgPC0gTkENCmZvciAobWluaXN0ZXBzIGluIDE6NTAwMCkgew0KICAgIHdhaXRpbmd0aW1lcyA8LSBOQQ0KICAgIHdhaXRpbmd0aW1lc1sxXSA8LSByZXhwKDEsIHJhdGUgPSA1KQ0KICAgIHdhaXRpbmd0aW1lc1syXSA8LSByZXhwKDEsIHJhdGUgPSAxMCkNCiAgICB3YWl0aW5ndGltZXNbM10gPC0gcmV4cCgxLCByYXRlID0gMTUpDQogICAgYWN0b3IgPC0gd2hpY2god2FpdGluZ3RpbWVzID09IG1pbih3YWl0aW5ndGltZXMpKQ0KICAgIHNhbV93YWl0aW5ndGltZXNbbWluaXN0ZXBzXSA8LSB3YWl0aW5ndGltZXNbYWN0b3JdDQp9DQoNCnBhcihtZnJvdyA9IGMoMSwgMikpDQpoaXN0KHNhbV93YWl0aW5ndGltZXMsIGZyZXEgPSBGQUxTRSwgeGxhYiA9ICJ3YWl0aW5nIHRpbWVzIiwgbWFpbiA9ICJzYW1wbGVkIHdhaXRpbmcgdGltZXMiKQ0KYWJsaW5lKHYgPSBtZWFuKHNhbV93YWl0aW5ndGltZXMpLCBjb2wgPSAicmVkIikNCg0KaGlzdChyZXhwKDUwMDAsIHJhdGUgPSAzMCksIGZyZXEgPSBGQUxTRSwgeGxhYiA9ICJ3YWl0aW5nIHRpbWVzIiwgbWFpbiA9ICJyYXRlPTMwIikNCmFibGluZSh2ID0gMS8zMCwgY29sID0gInJlZCIpDQpgYGANCg0KSWYgYW4gYWN0b3IgaGFzIGEgaGlnaGVyIHJhdGUgcGFyYW1ldGVyLCB0aGUgZXhwZWN0ZWQgc2FtcGxlZCB3YWl0aW5nIHRpbWUgaXMgc2hvcnRlci4gQW5kIHNpbmNlIHRoZSBhY3RvciB3aXRoIHRoZSBzaG9ydGVzdCB3YWl0aW5nIHRpbWUgd2lsbCBtYWtlIHRoZSBtaW5pc3RlcCwgYWN0b3JzIHdpdGggdGhlIGhpZ2hlc3QgcmF0ZSBwYXJhbWV0ZXIgaGF2ZSB0aGUgaGlnaGVzdCBwcm9iYWJpbGl0eSB0byBoYXZlIGFuIG9wcG9ydHVuaXR5IGZvciBjaGFuZ2UgLS0+IHRoZSBsYXJnZXIgdGhlIHJhdGUgcGFyYW1ldGVyIHRoZSBtb3JlIG9wcG9ydHVuaXRpZXMgZm9yIGNoYW5nZSB0aGVyZSBhcmUgd2l0aGluIGEgZ2l2ZW4gdGltZSBwZXJpb2QuDQoNClBsb3R0aW5nIHRoZSAjIG9mIG1pbmlzdGVwcyByZXF1aXJlZCB0byBzdXJwYXNzICcxJyBvdmVyIDEwMDAgc2FtcGxlczoNCmBgYHtyLCBldmFsPUZBTFNFfQ0Kc2V0LnNlZWQoMjQ1NjUxKQ0KDQpyZXN1bHRzIDwtIGxpc3QoKQ0KZm9yIChuc2ltIGluIDE6MTAwMCkgew0KICAgIHRpbWUgPC0gMA0KICAgIHN0ZXBzX3RvdCA8LSAwDQogICAgc3RlcHNfaSA8LSAwDQogICAgc3RlcHNfaiA8LSAwDQogICAgc3RlcHNfayA8LSAwDQogICAgYWN0b3JzIDwtIE5BDQogICAgd2hpbGUgKHRpbWUgPCAxKSB7DQogICAgICAgIHN0ZXBzX3RvdCA8LSBzdGVwc190b3QgKyAxDQogICAgICAgIHdhaXRpbmd0aW1lcyA8LSBOQQ0KICAgICAgICB3YWl0aW5ndGltZXNbMV0gPC0gcmV4cCgxLCByYXRlID0gNSkNCiAgICAgICAgd2FpdGluZ3RpbWVzWzJdIDwtIHJleHAoMSwgcmF0ZSA9IDEwKQ0KICAgICAgICB3YWl0aW5ndGltZXNbM10gPC0gcmV4cCgxLCByYXRlID0gMTUpDQogICAgICAgIGFjdG9yIDwtIHdoaWNoKHdhaXRpbmd0aW1lcyA9PSBtaW4od2FpdGluZ3RpbWVzKSkNCiAgICAgICAgdGltZSA8LSB0aW1lICsgd2FpdGluZ3RpbWVzW2FjdG9yXQ0KICAgICAgICBhY3RvcnNbc3RlcHNfdG90XSA8LSBhY3Rvcg0KICAgIH0NCiAgICByZXN1bHRzW1tuc2ltXV0gPC0gYWN0b3JzDQp9DQoNCiMgc3VtKHJlc3VsdHNbWzFdXT09MSkgaGlzdChzYXBwbHkocmVzdWx0cywgbGVuZ3RoKSkNCg0KcGFyKG1mcm93ID0gYygxLCAzKSkNCnsNCiAgICBoaXN0KHNhcHBseShyZXN1bHRzLCBmdW5jdGlvbih4KSB7DQogICAgICAgIHN1bSh4ID09IDEpDQogICAgfSksIHhsYWIgPSAibnN0ZXBzIiwgbWFpbiA9ICJhY3RvciBpOiBsYW1iZGE9NSIpDQogICAgYWJsaW5lKHYgPSBtZWFuKHNhcHBseShyZXN1bHRzLCBmdW5jdGlvbih4KSB7DQogICAgICAgIHN1bSh4ID09IDEpDQogICAgfSkpLCBjb2wgPSAicmVkIikNCn0NCg0Kew0KICAgIGhpc3Qoc2FwcGx5KHJlc3VsdHMsIGZ1bmN0aW9uKHgpIHsNCiAgICAgICAgc3VtKHggPT0gMikNCiAgICB9KSwgeGxhYiA9ICJuc3RlcHMiLCBtYWluID0gImFjdG9yIGo6IGxhbWJkYT0xMCIpDQogICAgYWJsaW5lKHYgPSBtZWFuKHNhcHBseShyZXN1bHRzLCBmdW5jdGlvbih4KSB7DQogICAgICAgIHN1bSh4ID09IDIpDQogICAgfSkpLCBjb2wgPSAicmVkIikNCn0NCg0Kew0KICAgIGhpc3Qoc2FwcGx5KHJlc3VsdHMsIGZ1bmN0aW9uKHgpIHsNCiAgICAgICAgc3VtKHggPT0gMykNCiAgICB9KSwgeGxhYiA9ICJuc3RlcHMiLCBtYWluID0gImFjdG9yIGs6IGxhbWJkYT0xNSIpDQogICAgYWJsaW5lKHYgPSBtZWFuKHNhcHBseShyZXN1bHRzLCBmdW5jdGlvbih4KSB7DQogICAgICAgIHN1bSh4ID09IDMpDQogICAgfSkpLCBjb2wgPSAicmVkIikNCn0NCmBgYA0KDQpDb25jbHVzaW9uOiB0aGUgbGFyZ2VyIHRoZSByYXRlIHBhcmFtZXRlciB0aGUgbW9yZSBvcHBvcnR1bml0aWVzIGZvciBjaGFuZ2UgcGVyIGFjdG9yIHRoZXJlIGFyZSB3aXRoaW4gYSBnaXZlbiB0aW1lIHBlcmlvZC4gQW5kIGluIFJTaWVuYSB0aGUgb3B0aW1hbCB2YWx1ZSBmb3IgdGhlIHJhdGUgcGFyYW1ldGVyIM67aSBpcyBlc3RpbWF0ZWQuIFRoZSBlc3RpbWF0ZWQgcGFyYW1ldGVyIGhhcyBhIG5pY2UgaW50ZXJwcmV0YXRpb246IHRoZSBlc3RpbWF0ZWQgcmF0ZSBwYXJhbWV0ZXIgcmVmZXJzIHRvIHRoZSBleHBlY3RlZCBudW1iZXIgb2Ygb3Bwb3J0dW5pdGllcyBmb3IgY2hhbmdlIGluIGEgdGltZSBwZXJpb2QuDQoNCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("summaryCh8&9.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
