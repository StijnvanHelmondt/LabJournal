<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="by: Stijn van Helmondt" />


<title>Summary Chapter 12</title>

<script src="site_libs/header-attrs-2.24/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    My journal
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 1</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="test.html">test1</a>
        </li>
        <li>
          <a href="test.html">test2</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 2</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="pracdes.html">descriptive statistics</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 3</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="summaryCh11.html">Summary SNASS chapter 11</a>
        </li>
        <li>
          <a href="webscraping_workshop.html">Workshop on webscraping</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 4</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="summaryCh12.html">Summary SNASS chapter 12</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 5</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="rSiena_dataprep.html">First introduction to dataprepping in rSiena</a>
        </li>
        <li>
          <a href="rSiena_prac_analyses.html">First introduction to analyses in rSiena</a>
        </li>
        <li>
          <a href="summaryCh8&amp;9.html">Summary SNASS chapter 8 and 9</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 6</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="summaryManualforSiena.html">Manual for RSiena</a>
        </li>
        <li>
          <a href="Descriptive_stats.html">First attempt at running descriptive statistics</a>
        </li>
      </ul>
    </li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">week 7 - Presentation</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="Probeersel.html">Unstructured overview of data processing for the paper</a>
        </li>
      </ul>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Final Research project
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="defIntroduction.html">Introduction</a>
    </li>
    <li>
      <a href="defTheory.html">Theory</a>
    </li>
    <li>
      <a href="defMethods.html">Methods</a>
    </li>
    <li>
      <a href="defResults.html">Results</a>
    </li>
    <li>
      <a href="Conc_Disc.html">Conclusion and discussion</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/StijnvanHelmondt/LabJournal">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Summary Chapter 12</h1>
<h4 class="author">by: Stijn van Helmondt</h4>

</div>


<p>Before making a (successful) network visualization it is important to
think why one wants a visualization in the first place. The answer ‘why’
depends on (1) Research question, (2) Descriptive statistics of the
data, (3) How preliminary network plots are able to convey your
message.</p>
<p>Making a visualization</p>
<pre class="r"><code>require(igraph)
g &lt;- make_graph(&quot;Zachary&quot;)
plot(g)</code></pre>
<p>Looking at which nodes have a connection</p>
<pre class="r"><code>gmat &lt;- as_adjacency_matrix(g, type = &quot;both&quot;, sparse = FALSE)
gmat</code></pre>
<div id="descriptive-statistics" class="section level1" number="1">
<h1><span class="header-section-number">1</span> 12.1 - Descriptive
statistics</h1>
<pre class="r"><code># Size of the network
# number of nodes
vcount(g)
# number of edges
ecount(g)

# Degree --&gt; the number of ties of a person
degree(g)
# hist(table(degree(g)), xlab=&#39;indegree&#39;, main= &#39;Histogram of indegree&#39;)

# Transitivity --&gt; if there is a. tie between A and B and one between B and C, then in a transitive network A and C will also be. connected. Be aware that directed graphs are considered as undirected. but g is undirected.
transitivity(g, type = c(&quot;localundirected&quot;), isolates = c(&quot;NaN&quot;, &quot;zero&quot;))

# Betweenness --&gt; measures the number of times a node lies on the shortest path between other nodes
igraph::betweenness(g, directed = FALSE)

# Dyad-census --&gt; A dyad is simply an unordered pair of vertices in a graph. As we have discussed previously, there are  dyads in an (undirected) graph of size n.
dyad.census(g)

# Triad-census --&gt; The possible connections between three nodes
igraph::triad.census(g)
# I will use sna because it shows the names of the triads as well.
sna::triad.census(gmat)

# Network visualisation with different sizes of dots, where a larger dot means more connections
V(g)$size = betweenness(g, normalized = T, directed = FALSE) * 60 + 10  #after some trial and error
plot(g, mode = &quot;undirected&quot;)

# A bit more space between nodes
set.seed(2345)
l &lt;- layout_with_mds(g)  #https://igraph.org/r/doc/layout_with_mds.html
plot(g, layout = l)

# More space between some nodes
l  #let us take a look at the coordinates
l[1, 1] &lt;- 4
l[34, 1] &lt;- -3.5
plot(g, layout = l)

# After manual data manipulation more visualisation, but always indicate what you&#39;ve done. Add a note/legend to your graph.
plot(g, layout = l, margin = c(0, 0, 0, 0))
legend(x = -2, y = -1.5, c(&quot;Note: the position of nodes 1 and 34 have been set by Jochem Tolsma \n for visualisation purposes only and do not reflect network properties&quot;),
    bty = &quot;n&quot;, cex = 0.8)</code></pre>
</div>
<div id="twitterdata-on-dutch-mps" class="section level1" number="2">
<h1><span class="header-section-number">2</span> 12.2 - Twitterdata on
Dutch MP’s</h1>
<pre class="r"><code>load(&quot;twitter_20190919.RData&quot;)
str(twitter_20190919, 1)
keyf &lt;- twitter_20190919[[1]] # --&gt; data on 147 MPs
mydata &lt;- twitter_20190919[[2]]
seats &lt;- twitter_20190919[[3]]

# We are going to focus on the atmentions of politicians. This is most closely related to political discussion. Thus who is having discussions with whom on Twitter? Let us go fishing for some data.
fnet &lt;- mydata$depvars$fnet
atmnet &lt;- mydata$depvars$atmnet
rtnet &lt;- mydata$depvars$rtnet

vrouw &lt;- mydata$cCovars$vrouw
partij &lt;- mydata$cCovars$partij
ethminz &lt;- mydata$cCovars$ethminz
lft &lt;- mydata$cCovars$lft

# if you construct an object for RSiena, covariates are mean centered by default. I would like to have the original values again.
ethminz &lt;- ethminz + attributes(ethminz)$mean
partij &lt;- partij + attributes(partij)$mean
vrouw &lt;- vrouw + attributes(vrouw)$mean
lft &lt;- lft + attributes(lft)$mean

# Look at the network data
str(fnet)

fnet1 &lt;- fnet[, , 1]  #friendship network wave 1
atmnet1 &lt;- atmnet[, , 1]  #atmention network wave 1 we will use wave 2 and 3 later.
atmnet2 &lt;- atmnet[, , 2]
atmnet3 &lt;- atmnet[, , 3]

# Recode missings into zero&#39;s

# table(fnet1, useNA=&#39;always&#39;) 
fnet1[fnet1 == 10] &lt;- 0
# table(fnet1, useNA=&#39;always&#39;) 

atmnet1[atmnet1 == 10] &lt;- 0
atmnet2[atmnet2 == 10] &lt;- 0
atmnet3[atmnet3 == 10] &lt;- 0</code></pre>
</div>
<div id="descriptive-statistics-1" class="section level1" number="3">
<h1><span class="header-section-number">3</span> 12.2.1 - Descriptive
statistics</h1>
<pre class="r"><code># Plotting 
G1 &lt;- igraph::graph_from_adjacency_matrix(atmnet1, mode = &quot;directed&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# Add the data to the graph
# Retrieve the edges.
edges &lt;- as_data_frame(G1, what = &quot;edges&quot;)

# The first variable of the data we can attach needs to be some id, thus reorder columns of keyf
keyf &lt;- cbind(keyf$EGOid, keyf[, names(keyf) != &quot;EGOid&quot;])
# the name has been changed as well. Lets correct this
names(keyf)[1] &lt;- &quot;EGOid&quot;

# rebuild the graph.
G1 &lt;- graph_from_data_frame(edges, directed = TRUE, vertices = keyf)

# let us examine the attributes
vertex_attr(G1)

# thus to find the names of our MPs we could now do this:
V(G1)$Naam

# Start plotting
plot(G1)

# Make it more seeable
G1 &lt;- simplify(G1)
plot(G1)

# Density of the network
edge_density(G1)</code></pre>
</div>
<div id="from-directed-to-reciprocated-ties" class="section level1"
number="4">
<h1><span class="header-section-number">4</span> 12.2.3 - From directed
to reciprocated ties</h1>
<pre class="r"><code># define undirected network
atmnet1_un &lt;- atmnet1 == 1 &amp; t(atmnet1) == 1

G2 &lt;- graph_from_adjacency_matrix(atmnet1_un, mode = &quot;undirected&quot;, weighted = NULL, diag = TRUE, add.colnames = NA,
    add.rownames = NA)

# attach data if you want
edges &lt;- as_data_frame(G2, what = &quot;edges&quot;)
G2 &lt;- graph_from_data_frame(edges, directed = FALSE, vertices = keyf)
plot(G2)

# As MPs mention themselves, let&#39;s simplify it

G2 &lt;- simplify(G2)
plot(G2, mode = &quot;undirected&quot;)</code></pre>
</div>
<div id="selecting-which-nodes-to-plot" class="section level1"
number="5">
<h1><span class="header-section-number">5</span> 12.2.4 Selecting which
nodes to plot</h1>
<pre class="r"><code># Remove the people who aren&#39;t mentioned by others. First make sure we don&#39;t end up with MPS who only mention themselves
diag(atmnet1_un) &lt;- 0

# lets find the noisolates
noisolates &lt;- rowSums(atmnet1_un, na.rm = T) &gt; 0
# length(noisolates) sum(noisolates) if you select, select both correct nomination network as ego characteristics
atmnet1_un_sel &lt;- atmnet1_un[noisolates, noisolates]
# if you are going to use the dataset keyf to add characteristics to the plot later, make sure to run the correct selection as well!
keyf_sel &lt;- keyf[noisolates, ]

G2_sel &lt;- graph_from_adjacency_matrix(atmnet1_un_sel, mode = &quot;undirected&quot;, weighted = NULL, diag = TRUE,
    add.colnames = NA, add.rownames = NA)
G2_sel &lt;- simplify(G2_sel)
plot(G2_sel, mode = &quot;undirected&quot;)

# Selecting on other characteristics, e.g. gender or political party 

# option 1: see above.  only select MPs from the liberal party
selection &lt;- keyf$Partij == &quot;VVD&quot;
# build new adjacency matrix
atmnet1_un_sel2 &lt;- atmnet1_un[selection, selection]

# option 2. Suppose we have attached our dataset to our graph object.  only select MPs from the liberal party
selection &lt;- V(G2)$Partij == &quot;VVD&quot;
selection_id &lt;- which(selection)  # this gives us a numeric variable
G_sel &lt;- induced_subgraph(G2, v = selection_id)
plot(G_sel)</code></pre>
</div>
<div id="changing-vertices" class="section level1" number="6">
<h1><span class="header-section-number">6</span> 12.2.5 - Changing
vertices</h1>
<pre class="r"><code># Two possible notations:
V(graph)$parameter &lt;- ...
plot(graph, vertex.parameter = ... )
# changing V
V(G2)$size = degree(G2) * 1.05  #naturally, you may use a different node-level structural characteristic here. 
plot(G2, mode = &quot;undirected&quot;)
# this equivalent to: plot(G2, vertex.size = degree(G2)*1.05)

# Labelling and giving the nodes a colour

V(G2)$label = as.character(V(G2)$Naam2)
V(G2)$label.cex = 1
V(G2)$color &lt;- ifelse(V(G2)$Geslacht == &quot;vrouw&quot;, &quot;red&quot;, &quot;green&quot;)
plot(G2, mode = &quot;undirected&quot;)</code></pre>
</div>
<div id="changing-edges" class="section level1" number="7">
<h1><span class="header-section-number">7</span> 12.2.6 - Changing
edges</h1>
<pre class="r"><code># Two possible notations:
E(graph)$parameter &lt;- ...
plot(graph, edge.parameter = ... )

# Changing arrow size and curvature

# changing E
E(G2)$arrow.size = 0.4
E(G2)$curved = 0.3
plot(G2, mode = &quot;undirected&quot;)

# Or equivalent to: 
plot(G2, mode= &#39;undirected&#39;, edge.arrow.size = .4, edge.curved=.3)</code></pre>
</div>
<div id="adding-a-legend" class="section level1" number="8">
<h1><span class="header-section-number">8</span> 12.2.7 - Adding a
legend</h1>
<pre class="r"><code># adding legend because I am working in Rmarkdown I need some {}
  plot.igraph(G2, margin = 0, mode = &quot;udirected&quot;)
legend(x = -1, y = -1, c(&quot;Female&quot;, &quot;Male&quot;), pch = 21, col = &quot;#777777&quot;, pt.bg = c(&quot;red&quot;, &quot;green&quot;), pt.cex = 2,
    cex = 0.8, bty = &quot;n&quot;, ncol = 1)</code></pre>
</div>
<div id="adding-coordinates" class="section level1" number="9">
<h1><span class="header-section-number">9</span> 12.2.8 - Adding
coordinates</h1>
<pre class="r"><code>plot(keyf$X, keyf$Y, xlim = c(-18, 18), ylim = c(-18, 18), col = keyf$Partij_col, pch = 16)

# Adding the MPs without twitter
# it really depends on your plotting window (size, resolution etc.) to get consistent results you need to define this beforehand. won&#39;t do that now.

# give nodes coler of their party
V(G2)$color &lt;- keyf$Partij_col

# change node size a bit
V(G2)$size = degree(G2) * 1.05 + 6

# remove the labels
V(G2)$label = &quot;&quot;

# less curvature
E(G2)$curved = 0.1

owncoords &lt;- cbind(keyf$X, keyf$Y)
owncoords &lt;- owncoords/8
owncoords[, 1] &lt;- (owncoords[, 1] - mean(owncoords[, 1]))
owncoords[, 2] &lt;- (owncoords[, 2] - mean(owncoords[, 2]))
plot.igraph(G2, mode = &quot;undirected&quot;, layout = owncoords, rescale = F, margin = c(0, 0, 0, 0), xlim = c(min(owncoords[,
    1]), max(owncoords[, 1])), ylim = c(min(owncoords[, 2]), max(owncoords[, 2])))</code></pre>
</div>
<div id="changing-edges-1" class="section level1" number="10">
<h1><span class="header-section-number">10</span> 12.2.9 - Changing
edges</h1>
<pre class="r"><code># We can change the edges based on dyad characteristics but if we have a weighted adjacency matrix also on the weights of the edges. To demonstrate this I first make a weighted atmention network. I simply sum whether MPs have mentioned each other in t1, t2 and t3.

# construct adjacency matrix first define the recipricated atmentions in each wave
atmnet1_un &lt;- atmnet1 == 1 &amp; t(atmnet1) == 1
atmnet2_un &lt;- atmnet2 == 1 &amp; t(atmnet2) == 1
atmnet3_un &lt;- atmnet3 == 1 &amp; t(atmnet3) == 1

atmnet_weighted &lt;- atmnet1_un + atmnet2_un + atmnet3_un

# contstruct graph / let us keep the loops note that the parameter &#39;weighted&#39; is set to true.
G_w &lt;- igraph::graph_from_adjacency_matrix(atmnet_weighted, mode = &quot;undirected&quot;, weighted = TRUE, diag = TRUE,
    add.colnames = NA, add.rownames = NA)

# attach data
edges &lt;- as_data_frame(G_w, what = &quot;edges&quot;)
# inspect the weight.
edges$weight  #not a lot of variation. 

# rebuild the graph.
G_w &lt;- graph_from_data_frame(edges, directed = FALSE, vertices = keyf)

# add changes as above
V(G_w)$color &lt;- keyf$Partij_col
V(G_w)$size = degree(G_w) * 1.05 + 6
V(G_w)$label = &quot;&quot;
E(G_w)$curved = 0.1

# add the weights
E(G_w)$width &lt;- E(G_w)$weight

plot.igraph(G_w, mode = &quot;undirected&quot;, layout = owncoords, rescale = F, margin = c(0, 0, 0, 0), xlim = c(min(owncoords[,
    1]), max(owncoords[, 1])), ylim = c(min(owncoords[, 2]), max(owncoords[, 2])))</code></pre>
</div>
<div id="changing-edge-based-on-dyad-characteristics"
class="section level1" number="11">
<h1><span class="header-section-number">11</span> Changing edge based on
dyad characteristics</h1>
<pre class="r"><code># let us make them the color of the nodes if it is between nodes from same party.  let us make them red if between parties

edges &lt;- get.adjacency(G_w)
edges_mat &lt;- matrix(as.numeric(edges), nrow = nrow(edges))
# edges_mat

# because we have undirected, we only need the edges once ...I know ...
edges_mat[lower.tri(edges_mat)] &lt;- 0
# table(keyf$Geslacht)

teller &lt;- 1
coloredges &lt;- NA
# we will loop over egos
for (i in 1:nrow(edges)) {
    # We then loop over alters
    for (j in 1:ncol(edges)) {
        # we check if there is a tie between ego and alter
        if (edges_mat[i, j] == 1) {
            # if so, we check ego and alter are from the same party if so, we give the tie the
            # color of the party
            if (keyf$Partij_col[i] == keyf$Partij_col[j]) {
                coloredges[teller] &lt;- keyf$Partij_col[i]
            }
            # if so, we check ego and alter are from the same party if not, we give the tie a
            # transparent grey color
            if (keyf$Partij_col[i] != keyf$Partij_col[j]) {
                coloredges[teller] &lt;- &quot;#0000004B&quot;
            }
            teller &lt;- teller + 1
        }
    }
}

E(G_w)$color = coloredges

# prepare a legend
Party_names &lt;- unique(keyf$Partij)
Party_cols &lt;- unique(keyf$Partij_col)
# reorder
Party_names &lt;- Party_names[c(7, 3, 9, 10, 12, 11, 5, 4, 6, 2, 8, 1, 13)]
Party_cols &lt;- Party_cols[c(7, 3, 9, 10, 12, 11, 5, 4, 6, 2, 8, 1, 13)]

# save the plot 
#  png(&#39;MPplotv2.png&#39;,width = 900, height= 900)
{

    plot.igraph(G_w, mode = &quot;undirected&quot;, layout = owncoords, rescale = F, margin = c(0, 0, 0, 0), xlim = c(min(owncoords[,
        1]), max(owncoords[, 1])), ylim = c(min(owncoords[, 2]), max(owncoords[, 2])))

    legend(&quot;topleft&quot;, legend = Party_names, pch = 21, col = &quot;#777777&quot;, pt.bg = Party_cols, pt.cex = 2,
        cex = 0.8, bty = &quot;n&quot;, ncol = 3)

    text(-2.2, -1.2, &quot;Note 1: Node size based on degree&quot;, adj = 0, cex = 0.8)
    text(-2.2, -1.3, &quot;Note 2: Edge color based on Party of MPs, black if MPs from different party&quot;, adj = 0,
        cex = 0.8)
    text(-2.2, -1.4, &quot;Note 3: Edge width based on number of @mentions&quot;, adj = 0, cex = 0.8)
}

# dev.off()</code></pre>
</div>
<div id="co-author-networks" class="section level1" number="12">
<h1><span class="header-section-number">12</span> 12.3 - Co-author
networks</h1>
<pre class="r"><code># load the necessary datasets
load(&quot;addfiles/soc_df.RData&quot;)
load(&quot;addfiles/soc_collabs1.RData&quot;)
load(&quot;addfiles/soc_collabs2.RData&quot;)

# get unique collaborators of soc staff first
soc_collabs_unique &lt;- unique(soc_collabs[, 4])  # so 229 unique collaborators for RU staff?
soc_collabs_unique &lt;- c(soc_collabs_unique, soc_df$gs_id)  # add the soc staff themselves.
soc_collabs_unique &lt;- data.frame(soc_collabs_unique)
soc_collabs_unique$v1 &lt;- 1  # convenient to select on after the merge
soc_collabs_unique &lt;- unique(soc_collabs_unique)


# so this is a very important step, we join the unique soc collaborators to the collaborators of collaborators
require(tidyverse)
onefivedegree &lt;- left_join(collabs_1deep, soc_collabs_unique, by = c(coauth_id = &quot;soc_collabs_unique&quot;))

# Then, we drop those that are not among sociology collaborators and who don&#39;t lsit coauthors regardless
onefivedegree &lt;- onefivedegree[!is.na(onefivedegree$v1), ]
onefivedegree &lt;- onefivedegree[!is.na(onefivedegree$coauth), ]

# we pick those columns and have an edgelist of soc collaborators and whether they collaborate with those same collaborators the 1.5 degree network
onefivedegree &lt;- onefivedegree[, c(&quot;name&quot;, &quot;coauth&quot;)]
names(onefivedegree) &lt;- c(&quot;from&quot;, &quot;to&quot;)

# we get soc collaborators and add those to the data above and end up with a nice edgelist!
socc &lt;- soc_collabs[!is.na(soc_collabs$coauth), ]
socc &lt;- socc[, c(&quot;name&quot;, &quot;coauth&quot;)]
names(socc) &lt;- c(&quot;from&quot;, &quot;to&quot;)
onefivedegree &lt;- rbind(socc, onefivedegree)
save(onefivedegree, file = &quot;soc_onefivedegree.RData&quot;)

# Plotting 
onefivedegree &lt;- as.matrix(onefivedegree)  # matrix because igraph wants that
library(igraph)  # Notice that we call igraph here, in anticipation of the viz tutorial.
net1 &lt;- graph_from_edgelist(onefivedegree, directed = TRUE)  # Notice the igraph function here!

plot(net1)  # Not readable/understandable!

# Making the plot better looking

plot(net1 ,
     vertex.color = &quot;gold&quot;, # nice color for the vertices
     vertex.size = 4,  # we&#39;ll vertices a bit smaller
     vertex.frame.color = &quot;gray&quot;,  # we&#39;ll put a gray frame around vertices
     vertex.label.color = &quot;black&quot;,  # not that ugly blue color for the labels (names)
     vertex.label.family = &quot;Helvetica&quot;, # not a fan of times new roman in figures
     vertex.label.cex = 0.4,  # make the label a bit smaller too
     vertex.label.dist = 0.5,  # we&#39;ll pull the labels a bit away from the vertices
     edge.curved = 0.2, # curved edges is always a nice touch
     edge.arrow.size = 0.1) # make arrow size (direction of edge) smaller

#Now, let’s try to extract the names in this network and see whether we can single out the staff members. Then I will label the column with a nice variable name.

in_network &lt;- data.frame(as_ids(V(net1)))
names(in_network)[1] &lt;- &quot;name&quot;

names(soc_df)

soc_df$total_cites &lt;- soc_df$total_cites.x
ru_nodes &lt;- soc_df[ c(&quot;name&quot;, &quot;h_index&quot;) ]
in_network &lt;- left_join(in_network, ru_nodes, by = c(&quot;name&quot; = &quot;name&quot;))
in_network$vcol &lt;- ifelse(is.na(in_network$h_index), &quot;#E69F00&quot;, &quot;#56B4E9&quot;) #  E69F00 and 56B4E9 are colour codes, use colourblind friendly colour, viridus colour palette is colourblind friendly

plot(net1,
     vertex.color = in_network$vcol, #THIS WAS WHAT WE DID THE LAST CODEBLOCK FOR!
     vertex.size = 4,  # we&#39;ll make them a bit smaller
     vertex.frame.color = &quot;gray&quot;,  # we&#39;ll put a frame around it
     vertex.label.color = &quot;black&quot;,  # not that ugly blue color for the names
     vertex.label.family = &quot;Helvetica&quot;, # not a fan of times in figures
     vertex.label.cex = 0.4,  # a bit smaller too
     vertex.label.dist = 0.5,  # we&#39;ll pull the labels a bit away from the vertices
     edge.curved = 0.2,  # curved edges is always a nice tough
     edge.arrow.size = 0.1) # arrow size smaller

# Now with only the names showing of RU-staff

plot(net1,
     vertex.color = in_network$vcol, 
     #NOTICE THESE CONDITIONAL STATEMENTS BELOW
     vertex.label = ifelse(!is.na(in_network$h_index), in_network$name, NA),
     vertex.size = 4,  # we&#39;ll make them a bit smaller
     vertex.frame.color = &quot;gray&quot;,  # we&#39;ll put a frame around it
     vertex.label.color = &quot;black&quot;,  # not that ugly blue color for the names
     vertex.label.family = &quot;Helvetica&quot;, # not a fan of times in figures
     vertex.label.cex = 0.65,  # a bit smaller too
     vertex.label.dist = 0.5,  # we&#39;ll pull the labels a bit away from the vertices
     edge.curved = 0.2, # curved edges is always a nice tough
     edge.arrow.size = 0.1) # arrow size smaller

# Making h_index a numeric variable
as.numeric(in_network$h_index)
in_network$h_indexn[is.na(in_network$h_indexn)] &lt;- 0
in_network$h_indexn





# Vertex size adjusted to show number of citations

plot(net1,
     vertex.color = in_network$vcol, 
     vertex.label = ifelse(!is.na(in_network$h_index), in_network$name, NA),
     # SAME HERE, TRY TO SMOOTH THE TOTAL_CITES A BIT WITH LOGSCALE
     vertex.size = ifelse(!is.na(in_network$h_indexn), log(in_network$h_indexn), 2),
     vertex.frame.color = &quot;gray&quot;,  # we&#39;ll put a frame around it
     vertex.label.color = &quot;black&quot;,  # not that ugly blue color for the names
     vertex.label.family = &quot;Helvetica&quot;, # not a fan of times in figures
     vertex.label.cex = 0.65,  # a bit smaller too
     vertex.label.dist = 0.5,  # we&#39;ll pull the labels a bit away from the vertices
     edge.curved = 0.2, # curved edges is always a nice tough
     edge.arrow.size = 0.1) # arrow size smaller</code></pre>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIlN1bW1hcnkgQ2hhcHRlciAxMiINCm91dHB1dDoNCiAgaHRtbF9kb2N1bWVudDoNCiAgICB0b2M6IHRydWUNCiAgICBudW1iZXJfc2VjdGlvbnM6IHRydWUNCmF1dGhvcjogImJ5OiBTdGlqbiB2YW4gSGVsbW9uZHQiDQpiaWJsaW9ncmFwaHk6IHJlZmVyZW5jZXMuYmliDQotLS0NCg0KQmVmb3JlIG1ha2luZyBhIChzdWNjZXNzZnVsKSBuZXR3b3JrIHZpc3VhbGl6YXRpb24gaXQgaXMgaW1wb3J0YW50IHRvIHRoaW5rIHdoeSBvbmUgd2FudHMgYSB2aXN1YWxpemF0aW9uIGluIHRoZSBmaXJzdCBwbGFjZS4gVGhlIGFuc3dlciAnd2h5JyBkZXBlbmRzIG9uICgxKSBSZXNlYXJjaCBxdWVzdGlvbiwgKDIpIERlc2NyaXB0aXZlIHN0YXRpc3RpY3Mgb2YgdGhlIGRhdGEsICgzKSBIb3cgcHJlbGltaW5hcnkgbmV0d29yayBwbG90cyBhcmUgYWJsZSB0byBjb252ZXkgeW91ciBtZXNzYWdlLg0KDQpNYWtpbmcgYSB2aXN1YWxpemF0aW9uDQpgYGB7ciwgZXZhbD1GQUxTRX0NCnJlcXVpcmUoaWdyYXBoKQ0KZyA8LSBtYWtlX2dyYXBoKCJaYWNoYXJ5IikNCnBsb3QoZykNCmBgYA0KDQpMb29raW5nIGF0IHdoaWNoIG5vZGVzIGhhdmUgYSBjb25uZWN0aW9uDQpgYGB7ciwgZXZhbD1GQUxTRX0NCmdtYXQgPC0gYXNfYWRqYWNlbmN5X21hdHJpeChnLCB0eXBlID0gImJvdGgiLCBzcGFyc2UgPSBGQUxTRSkNCmdtYXQNCmBgYA0KDQojIDEyLjEgLSBEZXNjcmlwdGl2ZSBzdGF0aXN0aWNzDQpgYGB7ciwgZXZhbD1GQUxTRX0NCiMgU2l6ZSBvZiB0aGUgbmV0d29yaw0KIyBudW1iZXIgb2Ygbm9kZXMNCnZjb3VudChnKQ0KIyBudW1iZXIgb2YgZWRnZXMNCmVjb3VudChnKQ0KDQojIERlZ3JlZSAtLT4gdGhlIG51bWJlciBvZiB0aWVzIG9mIGEgcGVyc29uDQpkZWdyZWUoZykNCiMgaGlzdCh0YWJsZShkZWdyZWUoZykpLCB4bGFiPSdpbmRlZ3JlZScsIG1haW49ICdIaXN0b2dyYW0gb2YgaW5kZWdyZWUnKQ0KDQojIFRyYW5zaXRpdml0eSAtLT4gaWYgdGhlcmUgaXMgYS4gdGllIGJldHdlZW4gQSBhbmQgQiBhbmQgb25lIGJldHdlZW4gQiBhbmQgQywgdGhlbiBpbiBhIHRyYW5zaXRpdmUgbmV0d29yayBBIGFuZCBDIHdpbGwgYWxzbyBiZS4gY29ubmVjdGVkLiBCZSBhd2FyZSB0aGF0IGRpcmVjdGVkIGdyYXBocyBhcmUgY29uc2lkZXJlZCBhcyB1bmRpcmVjdGVkLiBidXQgZyBpcyB1bmRpcmVjdGVkLg0KdHJhbnNpdGl2aXR5KGcsIHR5cGUgPSBjKCJsb2NhbHVuZGlyZWN0ZWQiKSwgaXNvbGF0ZXMgPSBjKCJOYU4iLCAiemVybyIpKQ0KDQojIEJldHdlZW5uZXNzIC0tPiBtZWFzdXJlcyB0aGUgbnVtYmVyIG9mIHRpbWVzIGEgbm9kZSBsaWVzIG9uIHRoZSBzaG9ydGVzdCBwYXRoIGJldHdlZW4gb3RoZXIgbm9kZXMNCmlncmFwaDo6YmV0d2Vlbm5lc3MoZywgZGlyZWN0ZWQgPSBGQUxTRSkNCg0KIyBEeWFkLWNlbnN1cyAtLT4gQSBkeWFkIGlzIHNpbXBseSBhbiB1bm9yZGVyZWQgcGFpciBvZiB2ZXJ0aWNlcyBpbiBhIGdyYXBoLiBBcyB3ZSBoYXZlIGRpc2N1c3NlZCBwcmV2aW91c2x5LCB0aGVyZSBhcmUgIGR5YWRzIGluIGFuICh1bmRpcmVjdGVkKSBncmFwaCBvZiBzaXplIG4uDQpkeWFkLmNlbnN1cyhnKQ0KDQojIFRyaWFkLWNlbnN1cyAtLT4gVGhlIHBvc3NpYmxlIGNvbm5lY3Rpb25zIGJldHdlZW4gdGhyZWUgbm9kZXMNCmlncmFwaDo6dHJpYWQuY2Vuc3VzKGcpDQojIEkgd2lsbCB1c2Ugc25hIGJlY2F1c2UgaXQgc2hvd3MgdGhlIG5hbWVzIG9mIHRoZSB0cmlhZHMgYXMgd2VsbC4NCnNuYTo6dHJpYWQuY2Vuc3VzKGdtYXQpDQoNCiMgTmV0d29yayB2aXN1YWxpc2F0aW9uIHdpdGggZGlmZmVyZW50IHNpemVzIG9mIGRvdHMsIHdoZXJlIGEgbGFyZ2VyIGRvdCBtZWFucyBtb3JlIGNvbm5lY3Rpb25zDQpWKGcpJHNpemUgPSBiZXR3ZWVubmVzcyhnLCBub3JtYWxpemVkID0gVCwgZGlyZWN0ZWQgPSBGQUxTRSkgKiA2MCArIDEwICAjYWZ0ZXIgc29tZSB0cmlhbCBhbmQgZXJyb3INCnBsb3QoZywgbW9kZSA9ICJ1bmRpcmVjdGVkIikNCg0KIyBBIGJpdCBtb3JlIHNwYWNlIGJldHdlZW4gbm9kZXMNCnNldC5zZWVkKDIzNDUpDQpsIDwtIGxheW91dF93aXRoX21kcyhnKSAgI2h0dHBzOi8vaWdyYXBoLm9yZy9yL2RvYy9sYXlvdXRfd2l0aF9tZHMuaHRtbA0KcGxvdChnLCBsYXlvdXQgPSBsKQ0KDQojIE1vcmUgc3BhY2UgYmV0d2VlbiBzb21lIG5vZGVzDQpsICAjbGV0IHVzIHRha2UgYSBsb29rIGF0IHRoZSBjb29yZGluYXRlcw0KbFsxLCAxXSA8LSA0DQpsWzM0LCAxXSA8LSAtMy41DQpwbG90KGcsIGxheW91dCA9IGwpDQoNCiMgQWZ0ZXIgbWFudWFsIGRhdGEgbWFuaXB1bGF0aW9uIG1vcmUgdmlzdWFsaXNhdGlvbiwgYnV0IGFsd2F5cyBpbmRpY2F0ZSB3aGF0IHlvdSd2ZSBkb25lLiBBZGQgYSBub3RlL2xlZ2VuZCB0byB5b3VyIGdyYXBoLg0KcGxvdChnLCBsYXlvdXQgPSBsLCBtYXJnaW4gPSBjKDAsIDAsIDAsIDApKQ0KbGVnZW5kKHggPSAtMiwgeSA9IC0xLjUsIGMoIk5vdGU6IHRoZSBwb3NpdGlvbiBvZiBub2RlcyAxIGFuZCAzNCBoYXZlIGJlZW4gc2V0IGJ5IEpvY2hlbSBUb2xzbWEgXG4gZm9yIHZpc3VhbGlzYXRpb24gcHVycG9zZXMgb25seSBhbmQgZG8gbm90IHJlZmxlY3QgbmV0d29yayBwcm9wZXJ0aWVzIiksDQogICAgYnR5ID0gIm4iLCBjZXggPSAwLjgpDQoNCg0KYGBgDQoNCiMgMTIuMiAtIFR3aXR0ZXJkYXRhIG9uIER1dGNoIE1QJ3MNCg0KYGBge3IsIGV2YWw9RkFMU0V9DQpsb2FkKCJ0d2l0dGVyXzIwMTkwOTE5LlJEYXRhIikNCnN0cih0d2l0dGVyXzIwMTkwOTE5LCAxKQ0Ka2V5ZiA8LSB0d2l0dGVyXzIwMTkwOTE5W1sxXV0gIyAtLT4gZGF0YSBvbiAxNDcgTVBzDQpteWRhdGEgPC0gdHdpdHRlcl8yMDE5MDkxOVtbMl1dDQpzZWF0cyA8LSB0d2l0dGVyXzIwMTkwOTE5W1szXV0NCg0KIyBXZSBhcmUgZ29pbmcgdG8gZm9jdXMgb24gdGhlIGF0bWVudGlvbnMgb2YgcG9saXRpY2lhbnMuIFRoaXMgaXMgbW9zdCBjbG9zZWx5IHJlbGF0ZWQgdG8gcG9saXRpY2FsIGRpc2N1c3Npb24uIFRodXMgd2hvIGlzIGhhdmluZyBkaXNjdXNzaW9ucyB3aXRoIHdob20gb24gVHdpdHRlcj8gTGV0IHVzIGdvIGZpc2hpbmcgZm9yIHNvbWUgZGF0YS4NCmZuZXQgPC0gbXlkYXRhJGRlcHZhcnMkZm5ldA0KYXRtbmV0IDwtIG15ZGF0YSRkZXB2YXJzJGF0bW5ldA0KcnRuZXQgPC0gbXlkYXRhJGRlcHZhcnMkcnRuZXQNCg0KdnJvdXcgPC0gbXlkYXRhJGNDb3ZhcnMkdnJvdXcNCnBhcnRpaiA8LSBteWRhdGEkY0NvdmFycyRwYXJ0aWoNCmV0aG1pbnogPC0gbXlkYXRhJGNDb3ZhcnMkZXRobWlueg0KbGZ0IDwtIG15ZGF0YSRjQ292YXJzJGxmdA0KDQojIGlmIHlvdSBjb25zdHJ1Y3QgYW4gb2JqZWN0IGZvciBSU2llbmEsIGNvdmFyaWF0ZXMgYXJlIG1lYW4gY2VudGVyZWQgYnkgZGVmYXVsdC4gSSB3b3VsZCBsaWtlIHRvIGhhdmUgdGhlIG9yaWdpbmFsIHZhbHVlcyBhZ2Fpbi4NCmV0aG1pbnogPC0gZXRobWlueiArIGF0dHJpYnV0ZXMoZXRobWlueikkbWVhbg0KcGFydGlqIDwtIHBhcnRpaiArIGF0dHJpYnV0ZXMocGFydGlqKSRtZWFuDQp2cm91dyA8LSB2cm91dyArIGF0dHJpYnV0ZXModnJvdXcpJG1lYW4NCmxmdCA8LSBsZnQgKyBhdHRyaWJ1dGVzKGxmdCkkbWVhbg0KDQojIExvb2sgYXQgdGhlIG5ldHdvcmsgZGF0YQ0Kc3RyKGZuZXQpDQoNCmZuZXQxIDwtIGZuZXRbLCAsIDFdICAjZnJpZW5kc2hpcCBuZXR3b3JrIHdhdmUgMQ0KYXRtbmV0MSA8LSBhdG1uZXRbLCAsIDFdICAjYXRtZW50aW9uIG5ldHdvcmsgd2F2ZSAxIHdlIHdpbGwgdXNlIHdhdmUgMiBhbmQgMyBsYXRlci4NCmF0bW5ldDIgPC0gYXRtbmV0WywgLCAyXQ0KYXRtbmV0MyA8LSBhdG1uZXRbLCAsIDNdDQoNCiMgUmVjb2RlIG1pc3NpbmdzIGludG8gemVybydzDQoNCiMgdGFibGUoZm5ldDEsIHVzZU5BPSdhbHdheXMnKSANCmZuZXQxW2ZuZXQxID09IDEwXSA8LSAwDQojIHRhYmxlKGZuZXQxLCB1c2VOQT0nYWx3YXlzJykgDQoNCmF0bW5ldDFbYXRtbmV0MSA9PSAxMF0gPC0gMA0KYXRtbmV0MlthdG1uZXQyID09IDEwXSA8LSAwDQphdG1uZXQzW2F0bW5ldDMgPT0gMTBdIDwtIDANCg0KYGBgDQoNCiMgMTIuMi4xIC0gRGVzY3JpcHRpdmUgc3RhdGlzdGljcw0KDQpgYGB7ciwgZXZhbD1GQUxTRX0NCiMgUGxvdHRpbmcgDQpHMSA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChhdG1uZXQxLCBtb2RlID0gImRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwgYWRkLmNvbG5hbWVzID0gTkEsDQogICAgYWRkLnJvd25hbWVzID0gTkEpDQoNCiMgQWRkIHRoZSBkYXRhIHRvIHRoZSBncmFwaA0KIyBSZXRyaWV2ZSB0aGUgZWRnZXMuDQplZGdlcyA8LSBhc19kYXRhX2ZyYW1lKEcxLCB3aGF0ID0gImVkZ2VzIikNCg0KIyBUaGUgZmlyc3QgdmFyaWFibGUgb2YgdGhlIGRhdGEgd2UgY2FuIGF0dGFjaCBuZWVkcyB0byBiZSBzb21lIGlkLCB0aHVzIHJlb3JkZXIgY29sdW1ucyBvZiBrZXlmDQprZXlmIDwtIGNiaW5kKGtleWYkRUdPaWQsIGtleWZbLCBuYW1lcyhrZXlmKSAhPSAiRUdPaWQiXSkNCiMgdGhlIG5hbWUgaGFzIGJlZW4gY2hhbmdlZCBhcyB3ZWxsLiBMZXRzIGNvcnJlY3QgdGhpcw0KbmFtZXMoa2V5ZilbMV0gPC0gIkVHT2lkIg0KDQojIHJlYnVpbGQgdGhlIGdyYXBoLg0KRzEgPC0gZ3JhcGhfZnJvbV9kYXRhX2ZyYW1lKGVkZ2VzLCBkaXJlY3RlZCA9IFRSVUUsIHZlcnRpY2VzID0ga2V5ZikNCg0KIyBsZXQgdXMgZXhhbWluZSB0aGUgYXR0cmlidXRlcw0KdmVydGV4X2F0dHIoRzEpDQoNCiMgdGh1cyB0byBmaW5kIHRoZSBuYW1lcyBvZiBvdXIgTVBzIHdlIGNvdWxkIG5vdyBkbyB0aGlzOg0KVihHMSkkTmFhbQ0KDQojIFN0YXJ0IHBsb3R0aW5nDQpwbG90KEcxKQ0KDQojIE1ha2UgaXQgbW9yZSBzZWVhYmxlDQpHMSA8LSBzaW1wbGlmeShHMSkNCnBsb3QoRzEpDQoNCiMgRGVuc2l0eSBvZiB0aGUgbmV0d29yaw0KZWRnZV9kZW5zaXR5KEcxKQ0KYGBgDQoNCiMgMTIuMi4zIC0gRnJvbSBkaXJlY3RlZCB0byByZWNpcHJvY2F0ZWQgdGllcw0KDQpgYGB7ciwgZXZhbD1GQUxTRX0NCiMgZGVmaW5lIHVuZGlyZWN0ZWQgbmV0d29yaw0KYXRtbmV0MV91biA8LSBhdG1uZXQxID09IDEgJiB0KGF0bW5ldDEpID09IDENCg0KRzIgPC0gZ3JhcGhfZnJvbV9hZGphY2VuY3lfbWF0cml4KGF0bW5ldDFfdW4sIG1vZGUgPSAidW5kaXJlY3RlZCIsIHdlaWdodGVkID0gTlVMTCwgZGlhZyA9IFRSVUUsIGFkZC5jb2xuYW1lcyA9IE5BLA0KICAgIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGF0dGFjaCBkYXRhIGlmIHlvdSB3YW50DQplZGdlcyA8LSBhc19kYXRhX2ZyYW1lKEcyLCB3aGF0ID0gImVkZ2VzIikNCkcyIDwtIGdyYXBoX2Zyb21fZGF0YV9mcmFtZShlZGdlcywgZGlyZWN0ZWQgPSBGQUxTRSwgdmVydGljZXMgPSBrZXlmKQ0KcGxvdChHMikNCg0KIyBBcyBNUHMgbWVudGlvbiB0aGVtc2VsdmVzLCBsZXQncyBzaW1wbGlmeSBpdA0KDQpHMiA8LSBzaW1wbGlmeShHMikNCnBsb3QoRzIsIG1vZGUgPSAidW5kaXJlY3RlZCIpDQpgYGANCg0KIyAxMi4yLjQgU2VsZWN0aW5nIHdoaWNoIG5vZGVzIHRvIHBsb3QNCg0KYGBge3IsIGV2YWw9RkFMU0V9DQojIFJlbW92ZSB0aGUgcGVvcGxlIHdobyBhcmVuJ3QgbWVudGlvbmVkIGJ5IG90aGVycy4gRmlyc3QgbWFrZSBzdXJlIHdlIGRvbid0IGVuZCB1cCB3aXRoIE1QUyB3aG8gb25seSBtZW50aW9uIHRoZW1zZWx2ZXMNCmRpYWcoYXRtbmV0MV91bikgPC0gMA0KDQojIGxldHMgZmluZCB0aGUgbm9pc29sYXRlcw0Kbm9pc29sYXRlcyA8LSByb3dTdW1zKGF0bW5ldDFfdW4sIG5hLnJtID0gVCkgPiAwDQojIGxlbmd0aChub2lzb2xhdGVzKSBzdW0obm9pc29sYXRlcykgaWYgeW91IHNlbGVjdCwgc2VsZWN0IGJvdGggY29ycmVjdCBub21pbmF0aW9uIG5ldHdvcmsgYXMgZWdvIGNoYXJhY3RlcmlzdGljcw0KYXRtbmV0MV91bl9zZWwgPC0gYXRtbmV0MV91bltub2lzb2xhdGVzLCBub2lzb2xhdGVzXQ0KIyBpZiB5b3UgYXJlIGdvaW5nIHRvIHVzZSB0aGUgZGF0YXNldCBrZXlmIHRvIGFkZCBjaGFyYWN0ZXJpc3RpY3MgdG8gdGhlIHBsb3QgbGF0ZXIsIG1ha2Ugc3VyZSB0byBydW4gdGhlIGNvcnJlY3Qgc2VsZWN0aW9uIGFzIHdlbGwhDQprZXlmX3NlbCA8LSBrZXlmW25vaXNvbGF0ZXMsIF0NCg0KRzJfc2VsIDwtIGdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChhdG1uZXQxX3VuX3NlbCwgbW9kZSA9ICJ1bmRpcmVjdGVkIiwgd2VpZ2h0ZWQgPSBOVUxMLCBkaWFnID0gVFJVRSwNCiAgICBhZGQuY29sbmFtZXMgPSBOQSwgYWRkLnJvd25hbWVzID0gTkEpDQpHMl9zZWwgPC0gc2ltcGxpZnkoRzJfc2VsKQ0KcGxvdChHMl9zZWwsIG1vZGUgPSAidW5kaXJlY3RlZCIpDQoNCiMgU2VsZWN0aW5nIG9uIG90aGVyIGNoYXJhY3RlcmlzdGljcywgZS5nLiBnZW5kZXIgb3IgcG9saXRpY2FsIHBhcnR5IA0KDQojIG9wdGlvbiAxOiBzZWUgYWJvdmUuICBvbmx5IHNlbGVjdCBNUHMgZnJvbSB0aGUgbGliZXJhbCBwYXJ0eQ0Kc2VsZWN0aW9uIDwtIGtleWYkUGFydGlqID09ICJWVkQiDQojIGJ1aWxkIG5ldyBhZGphY2VuY3kgbWF0cml4DQphdG1uZXQxX3VuX3NlbDIgPC0gYXRtbmV0MV91bltzZWxlY3Rpb24sIHNlbGVjdGlvbl0NCg0KIyBvcHRpb24gMi4gU3VwcG9zZSB3ZSBoYXZlIGF0dGFjaGVkIG91ciBkYXRhc2V0IHRvIG91ciBncmFwaCBvYmplY3QuICBvbmx5IHNlbGVjdCBNUHMgZnJvbSB0aGUgbGliZXJhbCBwYXJ0eQ0Kc2VsZWN0aW9uIDwtIFYoRzIpJFBhcnRpaiA9PSAiVlZEIg0Kc2VsZWN0aW9uX2lkIDwtIHdoaWNoKHNlbGVjdGlvbikgICMgdGhpcyBnaXZlcyB1cyBhIG51bWVyaWMgdmFyaWFibGUNCkdfc2VsIDwtIGluZHVjZWRfc3ViZ3JhcGgoRzIsIHYgPSBzZWxlY3Rpb25faWQpDQpwbG90KEdfc2VsKQ0KYGBgDQoNCiMgMTIuMi41IC0gQ2hhbmdpbmcgdmVydGljZXMNCg0KYGBge3IsIGV2YWw9RkFMU0V9DQojIFR3byBwb3NzaWJsZSBub3RhdGlvbnM6DQpWKGdyYXBoKSRwYXJhbWV0ZXIgPC0gLi4uDQpwbG90KGdyYXBoLCB2ZXJ0ZXgucGFyYW1ldGVyID0gLi4uICkNCiMgY2hhbmdpbmcgVg0KVihHMikkc2l6ZSA9IGRlZ3JlZShHMikgKiAxLjA1ICAjbmF0dXJhbGx5LCB5b3UgbWF5IHVzZSBhIGRpZmZlcmVudCBub2RlLWxldmVsIHN0cnVjdHVyYWwgY2hhcmFjdGVyaXN0aWMgaGVyZS4gDQpwbG90KEcyLCBtb2RlID0gInVuZGlyZWN0ZWQiKQ0KIyB0aGlzIGVxdWl2YWxlbnQgdG86IHBsb3QoRzIsIHZlcnRleC5zaXplID0gZGVncmVlKEcyKSoxLjA1KQ0KDQojIExhYmVsbGluZyBhbmQgZ2l2aW5nIHRoZSBub2RlcyBhIGNvbG91cg0KDQpWKEcyKSRsYWJlbCA9IGFzLmNoYXJhY3RlcihWKEcyKSROYWFtMikNClYoRzIpJGxhYmVsLmNleCA9IDENClYoRzIpJGNvbG9yIDwtIGlmZWxzZShWKEcyKSRHZXNsYWNodCA9PSAidnJvdXciLCAicmVkIiwgImdyZWVuIikNCnBsb3QoRzIsIG1vZGUgPSAidW5kaXJlY3RlZCIpDQpgYGANCg0KIyAxMi4yLjYgLSBDaGFuZ2luZyBlZGdlcw0KDQpgYGB7ciwgZXZhbD1GQUxTRX0NCiMgVHdvIHBvc3NpYmxlIG5vdGF0aW9uczoNCkUoZ3JhcGgpJHBhcmFtZXRlciA8LSAuLi4NCnBsb3QoZ3JhcGgsIGVkZ2UucGFyYW1ldGVyID0gLi4uICkNCg0KIyBDaGFuZ2luZyBhcnJvdyBzaXplIGFuZCBjdXJ2YXR1cmUNCg0KIyBjaGFuZ2luZyBFDQpFKEcyKSRhcnJvdy5zaXplID0gMC40DQpFKEcyKSRjdXJ2ZWQgPSAwLjMNCnBsb3QoRzIsIG1vZGUgPSAidW5kaXJlY3RlZCIpDQoNCiMgT3IgZXF1aXZhbGVudCB0bzogDQpwbG90KEcyLCBtb2RlPSAndW5kaXJlY3RlZCcsIGVkZ2UuYXJyb3cuc2l6ZSA9IC40LCBlZGdlLmN1cnZlZD0uMykNCmBgYA0KDQojIDEyLjIuNyAtIEFkZGluZyBhIGxlZ2VuZA0KDQpgYGB7ciwgZXZhbD1GQUxTRX0NCiMgYWRkaW5nIGxlZ2VuZCBiZWNhdXNlIEkgYW0gd29ya2luZyBpbiBSbWFya2Rvd24gSSBuZWVkIHNvbWUge30NCiAgcGxvdC5pZ3JhcGgoRzIsIG1hcmdpbiA9IDAsIG1vZGUgPSAidWRpcmVjdGVkIikNCmxlZ2VuZCh4ID0gLTEsIHkgPSAtMSwgYygiRmVtYWxlIiwgIk1hbGUiKSwgcGNoID0gMjEsIGNvbCA9ICIjNzc3Nzc3IiwgcHQuYmcgPSBjKCJyZWQiLCAiZ3JlZW4iKSwgcHQuY2V4ID0gMiwNCiAgICBjZXggPSAwLjgsIGJ0eSA9ICJuIiwgbmNvbCA9IDEpDQpgYGANCg0KIyAxMi4yLjggLSBBZGRpbmcgY29vcmRpbmF0ZXMNCg0KYGBge3IsIGV2YWw9RkFMU0V9DQpwbG90KGtleWYkWCwga2V5ZiRZLCB4bGltID0gYygtMTgsIDE4KSwgeWxpbSA9IGMoLTE4LCAxOCksIGNvbCA9IGtleWYkUGFydGlqX2NvbCwgcGNoID0gMTYpDQoNCiMgQWRkaW5nIHRoZSBNUHMgd2l0aG91dCB0d2l0dGVyDQojIGl0IHJlYWxseSBkZXBlbmRzIG9uIHlvdXIgcGxvdHRpbmcgd2luZG93IChzaXplLCByZXNvbHV0aW9uIGV0Yy4pIHRvIGdldCBjb25zaXN0ZW50IHJlc3VsdHMgeW91IG5lZWQgdG8gZGVmaW5lIHRoaXMgYmVmb3JlaGFuZC4gd29uJ3QgZG8gdGhhdCBub3cuDQoNCiMgZ2l2ZSBub2RlcyBjb2xlciBvZiB0aGVpciBwYXJ0eQ0KVihHMikkY29sb3IgPC0ga2V5ZiRQYXJ0aWpfY29sDQoNCiMgY2hhbmdlIG5vZGUgc2l6ZSBhIGJpdA0KVihHMikkc2l6ZSA9IGRlZ3JlZShHMikgKiAxLjA1ICsgNg0KDQojIHJlbW92ZSB0aGUgbGFiZWxzDQpWKEcyKSRsYWJlbCA9ICIiDQoNCiMgbGVzcyBjdXJ2YXR1cmUNCkUoRzIpJGN1cnZlZCA9IDAuMQ0KDQpvd25jb29yZHMgPC0gY2JpbmQoa2V5ZiRYLCBrZXlmJFkpDQpvd25jb29yZHMgPC0gb3duY29vcmRzLzgNCm93bmNvb3Jkc1ssIDFdIDwtIChvd25jb29yZHNbLCAxXSAtIG1lYW4ob3duY29vcmRzWywgMV0pKQ0Kb3duY29vcmRzWywgMl0gPC0gKG93bmNvb3Jkc1ssIDJdIC0gbWVhbihvd25jb29yZHNbLCAyXSkpDQpwbG90LmlncmFwaChHMiwgbW9kZSA9ICJ1bmRpcmVjdGVkIiwgbGF5b3V0ID0gb3duY29vcmRzLCByZXNjYWxlID0gRiwgbWFyZ2luID0gYygwLCAwLCAwLCAwKSwgeGxpbSA9IGMobWluKG93bmNvb3Jkc1ssDQogICAgMV0pLCBtYXgob3duY29vcmRzWywgMV0pKSwgeWxpbSA9IGMobWluKG93bmNvb3Jkc1ssIDJdKSwgbWF4KG93bmNvb3Jkc1ssIDJdKSkpDQoNCmBgYA0KDQojIDEyLjIuOSAtIENoYW5naW5nIGVkZ2VzDQoNCmBgYHtyLCBldmFsPUZBTFNFfQ0KIyBXZSBjYW4gY2hhbmdlIHRoZSBlZGdlcyBiYXNlZCBvbiBkeWFkIGNoYXJhY3RlcmlzdGljcyBidXQgaWYgd2UgaGF2ZSBhIHdlaWdodGVkIGFkamFjZW5jeSBtYXRyaXggYWxzbyBvbiB0aGUgd2VpZ2h0cyBvZiB0aGUgZWRnZXMuIFRvIGRlbW9uc3RyYXRlIHRoaXMgSSBmaXJzdCBtYWtlIGEgd2VpZ2h0ZWQgYXRtZW50aW9uIG5ldHdvcmsuIEkgc2ltcGx5IHN1bSB3aGV0aGVyIE1QcyBoYXZlIG1lbnRpb25lZCBlYWNoIG90aGVyIGluIHQxLCB0MiBhbmQgdDMuDQoNCiMgY29uc3RydWN0IGFkamFjZW5jeSBtYXRyaXggZmlyc3QgZGVmaW5lIHRoZSByZWNpcHJpY2F0ZWQgYXRtZW50aW9ucyBpbiBlYWNoIHdhdmUNCmF0bW5ldDFfdW4gPC0gYXRtbmV0MSA9PSAxICYgdChhdG1uZXQxKSA9PSAxDQphdG1uZXQyX3VuIDwtIGF0bW5ldDIgPT0gMSAmIHQoYXRtbmV0MikgPT0gMQ0KYXRtbmV0M191biA8LSBhdG1uZXQzID09IDEgJiB0KGF0bW5ldDMpID09IDENCg0KYXRtbmV0X3dlaWdodGVkIDwtIGF0bW5ldDFfdW4gKyBhdG1uZXQyX3VuICsgYXRtbmV0M191bg0KDQojIGNvbnRzdHJ1Y3QgZ3JhcGggLyBsZXQgdXMga2VlcCB0aGUgbG9vcHMgbm90ZSB0aGF0IHRoZSBwYXJhbWV0ZXIgJ3dlaWdodGVkJyBpcyBzZXQgdG8gdHJ1ZS4NCkdfdyA8LSBpZ3JhcGg6OmdyYXBoX2Zyb21fYWRqYWNlbmN5X21hdHJpeChhdG1uZXRfd2VpZ2h0ZWQsIG1vZGUgPSAidW5kaXJlY3RlZCIsIHdlaWdodGVkID0gVFJVRSwgZGlhZyA9IFRSVUUsDQogICAgYWRkLmNvbG5hbWVzID0gTkEsIGFkZC5yb3duYW1lcyA9IE5BKQ0KDQojIGF0dGFjaCBkYXRhDQplZGdlcyA8LSBhc19kYXRhX2ZyYW1lKEdfdywgd2hhdCA9ICJlZGdlcyIpDQojIGluc3BlY3QgdGhlIHdlaWdodC4NCmVkZ2VzJHdlaWdodCAgI25vdCBhIGxvdCBvZiB2YXJpYXRpb24uIA0KDQojIHJlYnVpbGQgdGhlIGdyYXBoLg0KR193IDwtIGdyYXBoX2Zyb21fZGF0YV9mcmFtZShlZGdlcywgZGlyZWN0ZWQgPSBGQUxTRSwgdmVydGljZXMgPSBrZXlmKQ0KDQojIGFkZCBjaGFuZ2VzIGFzIGFib3ZlDQpWKEdfdykkY29sb3IgPC0ga2V5ZiRQYXJ0aWpfY29sDQpWKEdfdykkc2l6ZSA9IGRlZ3JlZShHX3cpICogMS4wNSArIDYNClYoR193KSRsYWJlbCA9ICIiDQpFKEdfdykkY3VydmVkID0gMC4xDQoNCiMgYWRkIHRoZSB3ZWlnaHRzDQpFKEdfdykkd2lkdGggPC0gRShHX3cpJHdlaWdodA0KDQpwbG90LmlncmFwaChHX3csIG1vZGUgPSAidW5kaXJlY3RlZCIsIGxheW91dCA9IG93bmNvb3JkcywgcmVzY2FsZSA9IEYsIG1hcmdpbiA9IGMoMCwgMCwgMCwgMCksIHhsaW0gPSBjKG1pbihvd25jb29yZHNbLA0KICAgIDFdKSwgbWF4KG93bmNvb3Jkc1ssIDFdKSksIHlsaW0gPSBjKG1pbihvd25jb29yZHNbLCAyXSksIG1heChvd25jb29yZHNbLCAyXSkpKQ0KYGBgDQoNCiMgQ2hhbmdpbmcgZWRnZSBiYXNlZCBvbiBkeWFkIGNoYXJhY3RlcmlzdGljcw0KYGBge3IsIGV2YWw9RkFMU0V9DQojIGxldCB1cyBtYWtlIHRoZW0gdGhlIGNvbG9yIG9mIHRoZSBub2RlcyBpZiBpdCBpcyBiZXR3ZWVuIG5vZGVzIGZyb20gc2FtZSBwYXJ0eS4gIGxldCB1cyBtYWtlIHRoZW0gcmVkIGlmIGJldHdlZW4gcGFydGllcw0KDQplZGdlcyA8LSBnZXQuYWRqYWNlbmN5KEdfdykNCmVkZ2VzX21hdCA8LSBtYXRyaXgoYXMubnVtZXJpYyhlZGdlcyksIG5yb3cgPSBucm93KGVkZ2VzKSkNCiMgZWRnZXNfbWF0DQoNCiMgYmVjYXVzZSB3ZSBoYXZlIHVuZGlyZWN0ZWQsIHdlIG9ubHkgbmVlZCB0aGUgZWRnZXMgb25jZSAuLi5JIGtub3cgLi4uDQplZGdlc19tYXRbbG93ZXIudHJpKGVkZ2VzX21hdCldIDwtIDANCiMgdGFibGUoa2V5ZiRHZXNsYWNodCkNCg0KdGVsbGVyIDwtIDENCmNvbG9yZWRnZXMgPC0gTkENCiMgd2Ugd2lsbCBsb29wIG92ZXIgZWdvcw0KZm9yIChpIGluIDE6bnJvdyhlZGdlcykpIHsNCiAgICAjIFdlIHRoZW4gbG9vcCBvdmVyIGFsdGVycw0KICAgIGZvciAoaiBpbiAxOm5jb2woZWRnZXMpKSB7DQogICAgICAgICMgd2UgY2hlY2sgaWYgdGhlcmUgaXMgYSB0aWUgYmV0d2VlbiBlZ28gYW5kIGFsdGVyDQogICAgICAgIGlmIChlZGdlc19tYXRbaSwgal0gPT0gMSkgew0KICAgICAgICAgICAgIyBpZiBzbywgd2UgY2hlY2sgZWdvIGFuZCBhbHRlciBhcmUgZnJvbSB0aGUgc2FtZSBwYXJ0eSBpZiBzbywgd2UgZ2l2ZSB0aGUgdGllIHRoZQ0KICAgICAgICAgICAgIyBjb2xvciBvZiB0aGUgcGFydHkNCiAgICAgICAgICAgIGlmIChrZXlmJFBhcnRpal9jb2xbaV0gPT0ga2V5ZiRQYXJ0aWpfY29sW2pdKSB7DQogICAgICAgICAgICAgICAgY29sb3JlZGdlc1t0ZWxsZXJdIDwtIGtleWYkUGFydGlqX2NvbFtpXQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgIyBpZiBzbywgd2UgY2hlY2sgZWdvIGFuZCBhbHRlciBhcmUgZnJvbSB0aGUgc2FtZSBwYXJ0eSBpZiBub3QsIHdlIGdpdmUgdGhlIHRpZSBhDQogICAgICAgICAgICAjIHRyYW5zcGFyZW50IGdyZXkgY29sb3INCiAgICAgICAgICAgIGlmIChrZXlmJFBhcnRpal9jb2xbaV0gIT0ga2V5ZiRQYXJ0aWpfY29sW2pdKSB7DQogICAgICAgICAgICAgICAgY29sb3JlZGdlc1t0ZWxsZXJdIDwtICIjMDAwMDAwNEIiDQogICAgICAgICAgICB9DQogICAgICAgICAgICB0ZWxsZXIgPC0gdGVsbGVyICsgMQ0KICAgICAgICB9DQogICAgfQ0KfQ0KDQpFKEdfdykkY29sb3IgPSBjb2xvcmVkZ2VzDQoNCiMgcHJlcGFyZSBhIGxlZ2VuZA0KUGFydHlfbmFtZXMgPC0gdW5pcXVlKGtleWYkUGFydGlqKQ0KUGFydHlfY29scyA8LSB1bmlxdWUoa2V5ZiRQYXJ0aWpfY29sKQ0KIyByZW9yZGVyDQpQYXJ0eV9uYW1lcyA8LSBQYXJ0eV9uYW1lc1tjKDcsIDMsIDksIDEwLCAxMiwgMTEsIDUsIDQsIDYsIDIsIDgsIDEsIDEzKV0NClBhcnR5X2NvbHMgPC0gUGFydHlfY29sc1tjKDcsIDMsIDksIDEwLCAxMiwgMTEsIDUsIDQsIDYsIDIsIDgsIDEsIDEzKV0NCg0KIyBzYXZlIHRoZSBwbG90IA0KIyAgcG5nKCdNUHBsb3R2Mi5wbmcnLHdpZHRoID0gOTAwLCBoZWlnaHQ9IDkwMCkNCnsNCg0KICAgIHBsb3QuaWdyYXBoKEdfdywgbW9kZSA9ICJ1bmRpcmVjdGVkIiwgbGF5b3V0ID0gb3duY29vcmRzLCByZXNjYWxlID0gRiwgbWFyZ2luID0gYygwLCAwLCAwLCAwKSwgeGxpbSA9IGMobWluKG93bmNvb3Jkc1ssDQogICAgICAgIDFdKSwgbWF4KG93bmNvb3Jkc1ssIDFdKSksIHlsaW0gPSBjKG1pbihvd25jb29yZHNbLCAyXSksIG1heChvd25jb29yZHNbLCAyXSkpKQ0KDQogICAgbGVnZW5kKCJ0b3BsZWZ0IiwgbGVnZW5kID0gUGFydHlfbmFtZXMsIHBjaCA9IDIxLCBjb2wgPSAiIzc3Nzc3NyIsIHB0LmJnID0gUGFydHlfY29scywgcHQuY2V4ID0gMiwNCiAgICAgICAgY2V4ID0gMC44LCBidHkgPSAibiIsIG5jb2wgPSAzKQ0KDQogICAgdGV4dCgtMi4yLCAtMS4yLCAiTm90ZSAxOiBOb2RlIHNpemUgYmFzZWQgb24gZGVncmVlIiwgYWRqID0gMCwgY2V4ID0gMC44KQ0KICAgIHRleHQoLTIuMiwgLTEuMywgIk5vdGUgMjogRWRnZSBjb2xvciBiYXNlZCBvbiBQYXJ0eSBvZiBNUHMsIGJsYWNrIGlmIE1QcyBmcm9tIGRpZmZlcmVudCBwYXJ0eSIsIGFkaiA9IDAsDQogICAgICAgIGNleCA9IDAuOCkNCiAgICB0ZXh0KC0yLjIsIC0xLjQsICJOb3RlIDM6IEVkZ2Ugd2lkdGggYmFzZWQgb24gbnVtYmVyIG9mIEBtZW50aW9ucyIsIGFkaiA9IDAsIGNleCA9IDAuOCkNCn0NCg0KIyBkZXYub2ZmKCkNCmBgYA0KDQojIDEyLjMgLSBDby1hdXRob3IgbmV0d29ya3MNCg0KYGBge3IsIGV2YWw9RkFMU0V9ICANCiMgbG9hZCB0aGUgbmVjZXNzYXJ5IGRhdGFzZXRzDQpsb2FkKCJhZGRmaWxlcy9zb2NfZGYuUkRhdGEiKQ0KbG9hZCgiYWRkZmlsZXMvc29jX2NvbGxhYnMxLlJEYXRhIikNCmxvYWQoImFkZGZpbGVzL3NvY19jb2xsYWJzMi5SRGF0YSIpDQoNCiMgZ2V0IHVuaXF1ZSBjb2xsYWJvcmF0b3JzIG9mIHNvYyBzdGFmZiBmaXJzdA0Kc29jX2NvbGxhYnNfdW5pcXVlIDwtIHVuaXF1ZShzb2NfY29sbGFic1ssIDRdKSAgIyBzbyAyMjkgdW5pcXVlIGNvbGxhYm9yYXRvcnMgZm9yIFJVIHN0YWZmPw0Kc29jX2NvbGxhYnNfdW5pcXVlIDwtIGMoc29jX2NvbGxhYnNfdW5pcXVlLCBzb2NfZGYkZ3NfaWQpICAjIGFkZCB0aGUgc29jIHN0YWZmIHRoZW1zZWx2ZXMuDQpzb2NfY29sbGFic191bmlxdWUgPC0gZGF0YS5mcmFtZShzb2NfY29sbGFic191bmlxdWUpDQpzb2NfY29sbGFic191bmlxdWUkdjEgPC0gMSAgIyBjb252ZW5pZW50IHRvIHNlbGVjdCBvbiBhZnRlciB0aGUgbWVyZ2UNCnNvY19jb2xsYWJzX3VuaXF1ZSA8LSB1bmlxdWUoc29jX2NvbGxhYnNfdW5pcXVlKQ0KDQoNCiMgc28gdGhpcyBpcyBhIHZlcnkgaW1wb3J0YW50IHN0ZXAsIHdlIGpvaW4gdGhlIHVuaXF1ZSBzb2MgY29sbGFib3JhdG9ycyB0byB0aGUgY29sbGFib3JhdG9ycyBvZiBjb2xsYWJvcmF0b3JzDQpyZXF1aXJlKHRpZHl2ZXJzZSkNCm9uZWZpdmVkZWdyZWUgPC0gbGVmdF9qb2luKGNvbGxhYnNfMWRlZXAsIHNvY19jb2xsYWJzX3VuaXF1ZSwgYnkgPSBjKGNvYXV0aF9pZCA9ICJzb2NfY29sbGFic191bmlxdWUiKSkNCg0KIyBUaGVuLCB3ZSBkcm9wIHRob3NlIHRoYXQgYXJlIG5vdCBhbW9uZyBzb2Npb2xvZ3kgY29sbGFib3JhdG9ycyBhbmQgd2hvIGRvbid0IGxzaXQgY29hdXRob3JzIHJlZ2FyZGxlc3MNCm9uZWZpdmVkZWdyZWUgPC0gb25lZml2ZWRlZ3JlZVshaXMubmEob25lZml2ZWRlZ3JlZSR2MSksIF0NCm9uZWZpdmVkZWdyZWUgPC0gb25lZml2ZWRlZ3JlZVshaXMubmEob25lZml2ZWRlZ3JlZSRjb2F1dGgpLCBdDQoNCiMgd2UgcGljayB0aG9zZSBjb2x1bW5zIGFuZCBoYXZlIGFuIGVkZ2VsaXN0IG9mIHNvYyBjb2xsYWJvcmF0b3JzIGFuZCB3aGV0aGVyIHRoZXkgY29sbGFib3JhdGUgd2l0aCB0aG9zZSBzYW1lIGNvbGxhYm9yYXRvcnMgdGhlIDEuNSBkZWdyZWUgbmV0d29yaw0Kb25lZml2ZWRlZ3JlZSA8LSBvbmVmaXZlZGVncmVlWywgYygibmFtZSIsICJjb2F1dGgiKV0NCm5hbWVzKG9uZWZpdmVkZWdyZWUpIDwtIGMoImZyb20iLCAidG8iKQ0KDQojIHdlIGdldCBzb2MgY29sbGFib3JhdG9ycyBhbmQgYWRkIHRob3NlIHRvIHRoZSBkYXRhIGFib3ZlIGFuZCBlbmQgdXAgd2l0aCBhIG5pY2UgZWRnZWxpc3QhDQpzb2NjIDwtIHNvY19jb2xsYWJzWyFpcy5uYShzb2NfY29sbGFicyRjb2F1dGgpLCBdDQpzb2NjIDwtIHNvY2NbLCBjKCJuYW1lIiwgImNvYXV0aCIpXQ0KbmFtZXMoc29jYykgPC0gYygiZnJvbSIsICJ0byIpDQpvbmVmaXZlZGVncmVlIDwtIHJiaW5kKHNvY2MsIG9uZWZpdmVkZWdyZWUpDQpzYXZlKG9uZWZpdmVkZWdyZWUsIGZpbGUgPSAic29jX29uZWZpdmVkZWdyZWUuUkRhdGEiKQ0KDQojIFBsb3R0aW5nIA0Kb25lZml2ZWRlZ3JlZSA8LSBhcy5tYXRyaXgob25lZml2ZWRlZ3JlZSkgICMgbWF0cml4IGJlY2F1c2UgaWdyYXBoIHdhbnRzIHRoYXQNCmxpYnJhcnkoaWdyYXBoKSAgIyBOb3RpY2UgdGhhdCB3ZSBjYWxsIGlncmFwaCBoZXJlLCBpbiBhbnRpY2lwYXRpb24gb2YgdGhlIHZpeiB0dXRvcmlhbC4NCm5ldDEgPC0gZ3JhcGhfZnJvbV9lZGdlbGlzdChvbmVmaXZlZGVncmVlLCBkaXJlY3RlZCA9IFRSVUUpICAjIE5vdGljZSB0aGUgaWdyYXBoIGZ1bmN0aW9uIGhlcmUhDQoNCnBsb3QobmV0MSkgICMgTm90IHJlYWRhYmxlL3VuZGVyc3RhbmRhYmxlIQ0KDQojIE1ha2luZyB0aGUgcGxvdCBiZXR0ZXIgbG9va2luZw0KDQpwbG90KG5ldDEgLA0KICAgICB2ZXJ0ZXguY29sb3IgPSAiZ29sZCIsICMgbmljZSBjb2xvciBmb3IgdGhlIHZlcnRpY2VzDQogICAgIHZlcnRleC5zaXplID0gNCwgICMgd2UnbGwgdmVydGljZXMgYSBiaXQgc21hbGxlcg0KICAgICB2ZXJ0ZXguZnJhbWUuY29sb3IgPSAiZ3JheSIsICAjIHdlJ2xsIHB1dCBhIGdyYXkgZnJhbWUgYXJvdW5kIHZlcnRpY2VzDQogICAgIHZlcnRleC5sYWJlbC5jb2xvciA9ICJibGFjayIsICAjIG5vdCB0aGF0IHVnbHkgYmx1ZSBjb2xvciBmb3IgdGhlIGxhYmVscyAobmFtZXMpDQogICAgIHZlcnRleC5sYWJlbC5mYW1pbHkgPSAiSGVsdmV0aWNhIiwgIyBub3QgYSBmYW4gb2YgdGltZXMgbmV3IHJvbWFuIGluIGZpZ3VyZXMNCiAgICAgdmVydGV4LmxhYmVsLmNleCA9IDAuNCwgICMgbWFrZSB0aGUgbGFiZWwgYSBiaXQgc21hbGxlciB0b28NCiAgICAgdmVydGV4LmxhYmVsLmRpc3QgPSAwLjUsICAjIHdlJ2xsIHB1bGwgdGhlIGxhYmVscyBhIGJpdCBhd2F5IGZyb20gdGhlIHZlcnRpY2VzDQogICAgIGVkZ2UuY3VydmVkID0gMC4yLCAjIGN1cnZlZCBlZGdlcyBpcyBhbHdheXMgYSBuaWNlIHRvdWNoDQogICAgIGVkZ2UuYXJyb3cuc2l6ZSA9IDAuMSkgIyBtYWtlIGFycm93IHNpemUgKGRpcmVjdGlvbiBvZiBlZGdlKSBzbWFsbGVyDQoNCiNOb3csIGxldOKAmXMgdHJ5IHRvIGV4dHJhY3QgdGhlIG5hbWVzIGluIHRoaXMgbmV0d29yayBhbmQgc2VlIHdoZXRoZXIgd2UgY2FuIHNpbmdsZSBvdXQgdGhlIHN0YWZmIG1lbWJlcnMuIFRoZW4gSSB3aWxsIGxhYmVsIHRoZSBjb2x1bW4gd2l0aCBhIG5pY2UgdmFyaWFibGUgbmFtZS4NCg0KaW5fbmV0d29yayA8LSBkYXRhLmZyYW1lKGFzX2lkcyhWKG5ldDEpKSkNCm5hbWVzKGluX25ldHdvcmspWzFdIDwtICJuYW1lIg0KDQpuYW1lcyhzb2NfZGYpDQoNCnNvY19kZiR0b3RhbF9jaXRlcyA8LSBzb2NfZGYkdG90YWxfY2l0ZXMueA0KcnVfbm9kZXMgPC0gc29jX2RmWyBjKCJuYW1lIiwgImhfaW5kZXgiKSBdDQppbl9uZXR3b3JrIDwtIGxlZnRfam9pbihpbl9uZXR3b3JrLCBydV9ub2RlcywgYnkgPSBjKCJuYW1lIiA9ICJuYW1lIikpDQppbl9uZXR3b3JrJHZjb2wgPC0gaWZlbHNlKGlzLm5hKGluX25ldHdvcmskaF9pbmRleCksICIjRTY5RjAwIiwgIiM1NkI0RTkiKSAjICBFNjlGMDAgYW5kIDU2QjRFOSBhcmUgY29sb3VyIGNvZGVzLCB1c2UgY29sb3VyYmxpbmQgZnJpZW5kbHkgY29sb3VyLCB2aXJpZHVzIGNvbG91ciBwYWxldHRlIGlzIGNvbG91cmJsaW5kIGZyaWVuZGx5DQoNCnBsb3QobmV0MSwNCiAgICAgdmVydGV4LmNvbG9yID0gaW5fbmV0d29yayR2Y29sLCAjVEhJUyBXQVMgV0hBVCBXRSBESUQgVEhFIExBU1QgQ09ERUJMT0NLIEZPUiENCiAgICAgdmVydGV4LnNpemUgPSA0LCAgIyB3ZSdsbCBtYWtlIHRoZW0gYSBiaXQgc21hbGxlcg0KICAgICB2ZXJ0ZXguZnJhbWUuY29sb3IgPSAiZ3JheSIsICAjIHdlJ2xsIHB1dCBhIGZyYW1lIGFyb3VuZCBpdA0KICAgICB2ZXJ0ZXgubGFiZWwuY29sb3IgPSAiYmxhY2siLCAgIyBub3QgdGhhdCB1Z2x5IGJsdWUgY29sb3IgZm9yIHRoZSBuYW1lcw0KICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5ID0gIkhlbHZldGljYSIsICMgbm90IGEgZmFuIG9mIHRpbWVzIGluIGZpZ3VyZXMNCiAgICAgdmVydGV4LmxhYmVsLmNleCA9IDAuNCwgICMgYSBiaXQgc21hbGxlciB0b28NCiAgICAgdmVydGV4LmxhYmVsLmRpc3QgPSAwLjUsICAjIHdlJ2xsIHB1bGwgdGhlIGxhYmVscyBhIGJpdCBhd2F5IGZyb20gdGhlIHZlcnRpY2VzDQogICAgIGVkZ2UuY3VydmVkID0gMC4yLCAgIyBjdXJ2ZWQgZWRnZXMgaXMgYWx3YXlzIGEgbmljZSB0b3VnaA0KICAgICBlZGdlLmFycm93LnNpemUgPSAwLjEpICMgYXJyb3cgc2l6ZSBzbWFsbGVyDQoNCiMgTm93IHdpdGggb25seSB0aGUgbmFtZXMgc2hvd2luZyBvZiBSVS1zdGFmZg0KDQpwbG90KG5ldDEsDQogICAgIHZlcnRleC5jb2xvciA9IGluX25ldHdvcmskdmNvbCwgDQogICAgICNOT1RJQ0UgVEhFU0UgQ09ORElUSU9OQUwgU1RBVEVNRU5UUyBCRUxPVw0KICAgICB2ZXJ0ZXgubGFiZWwgPSBpZmVsc2UoIWlzLm5hKGluX25ldHdvcmskaF9pbmRleCksIGluX25ldHdvcmskbmFtZSwgTkEpLA0KICAgICB2ZXJ0ZXguc2l6ZSA9IDQsICAjIHdlJ2xsIG1ha2UgdGhlbSBhIGJpdCBzbWFsbGVyDQogICAgIHZlcnRleC5mcmFtZS5jb2xvciA9ICJncmF5IiwgICMgd2UnbGwgcHV0IGEgZnJhbWUgYXJvdW5kIGl0DQogICAgIHZlcnRleC5sYWJlbC5jb2xvciA9ICJibGFjayIsICAjIG5vdCB0aGF0IHVnbHkgYmx1ZSBjb2xvciBmb3IgdGhlIG5hbWVzDQogICAgIHZlcnRleC5sYWJlbC5mYW1pbHkgPSAiSGVsdmV0aWNhIiwgIyBub3QgYSBmYW4gb2YgdGltZXMgaW4gZmlndXJlcw0KICAgICB2ZXJ0ZXgubGFiZWwuY2V4ID0gMC42NSwgICMgYSBiaXQgc21hbGxlciB0b28NCiAgICAgdmVydGV4LmxhYmVsLmRpc3QgPSAwLjUsICAjIHdlJ2xsIHB1bGwgdGhlIGxhYmVscyBhIGJpdCBhd2F5IGZyb20gdGhlIHZlcnRpY2VzDQogICAgIGVkZ2UuY3VydmVkID0gMC4yLCAjIGN1cnZlZCBlZGdlcyBpcyBhbHdheXMgYSBuaWNlIHRvdWdoDQogICAgIGVkZ2UuYXJyb3cuc2l6ZSA9IDAuMSkgIyBhcnJvdyBzaXplIHNtYWxsZXINCg0KIyBNYWtpbmcgaF9pbmRleCBhIG51bWVyaWMgdmFyaWFibGUNCmFzLm51bWVyaWMoaW5fbmV0d29yayRoX2luZGV4KQ0KaW5fbmV0d29yayRoX2luZGV4bltpcy5uYShpbl9uZXR3b3JrJGhfaW5kZXhuKV0gPC0gMA0KaW5fbmV0d29yayRoX2luZGV4bg0KDQoNCg0KDQoNCiMgVmVydGV4IHNpemUgYWRqdXN0ZWQgdG8gc2hvdyBudW1iZXIgb2YgY2l0YXRpb25zDQoNCnBsb3QobmV0MSwNCiAgICAgdmVydGV4LmNvbG9yID0gaW5fbmV0d29yayR2Y29sLCANCiAgICAgdmVydGV4LmxhYmVsID0gaWZlbHNlKCFpcy5uYShpbl9uZXR3b3JrJGhfaW5kZXgpLCBpbl9uZXR3b3JrJG5hbWUsIE5BKSwNCiAgICAgIyBTQU1FIEhFUkUsIFRSWSBUTyBTTU9PVEggVEhFIFRPVEFMX0NJVEVTIEEgQklUIFdJVEggTE9HU0NBTEUNCiAgICAgdmVydGV4LnNpemUgPSBpZmVsc2UoIWlzLm5hKGluX25ldHdvcmskaF9pbmRleG4pLCBsb2coaW5fbmV0d29yayRoX2luZGV4biksIDIpLA0KICAgICB2ZXJ0ZXguZnJhbWUuY29sb3IgPSAiZ3JheSIsICAjIHdlJ2xsIHB1dCBhIGZyYW1lIGFyb3VuZCBpdA0KICAgICB2ZXJ0ZXgubGFiZWwuY29sb3IgPSAiYmxhY2siLCAgIyBub3QgdGhhdCB1Z2x5IGJsdWUgY29sb3IgZm9yIHRoZSBuYW1lcw0KICAgICB2ZXJ0ZXgubGFiZWwuZmFtaWx5ID0gIkhlbHZldGljYSIsICMgbm90IGEgZmFuIG9mIHRpbWVzIGluIGZpZ3VyZXMNCiAgICAgdmVydGV4LmxhYmVsLmNleCA9IDAuNjUsICAjIGEgYml0IHNtYWxsZXIgdG9vDQogICAgIHZlcnRleC5sYWJlbC5kaXN0ID0gMC41LCAgIyB3ZSdsbCBwdWxsIHRoZSBsYWJlbHMgYSBiaXQgYXdheSBmcm9tIHRoZSB2ZXJ0aWNlcw0KICAgICBlZGdlLmN1cnZlZCA9IDAuMiwgIyBjdXJ2ZWQgZWRnZXMgaXMgYWx3YXlzIGEgbmljZSB0b3VnaA0KICAgICBlZGdlLmFycm93LnNpemUgPSAwLjEpICMgYXJyb3cgc2l6ZSBzbWFsbGVyDQoNCg0KDQoNCmBgYA0KDQoNCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("summaryCh12.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
